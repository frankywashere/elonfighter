<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <title>Street Fighter II - Enhanced Graphics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            /* Support for Safari safe areas */
            padding-top: env(safe-area-inset-top);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            /* Fullscreen support */
            position: fixed;
            width: 100%;
            height: 100%;
            /* Prevent bouncing on iOS */
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: none;
        }
        #gameContainer {
            position: relative;
            filter: contrast(1.1) saturate(1.2);
        }
        canvas {
            border: 4px solid #222;
            box-shadow: 0 0 40px rgba(0,0,0,0.8), inset 0 0 20px rgba(0,0,0,0.5);
            background: #000;
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
        .controls {
            display: none; /* Hide keyboard controls on mobile */
        }
        
        @media (min-width: 769px) {
            .controls {
                display: block;
                position: absolute;
                bottom: -50px;
                left: 50%;
                transform: translateX(-50%);
                color: #fff;
                text-align: center;
                font-size: 11px;
                background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0.7));
                padding: 10px 20px;
                border-radius: 10px;
                border: 1px solid #444;
                text-shadow: 2px 2px 4px #000;
            }
        }
        .combo-display {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #ffff00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9), 0 0 20px rgba(255,255,0,0.5);
            font-family: 'Impact', sans-serif;
            letter-spacing: 2px;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .combo-display.active {
            animation: pulse 0.3s ease-in-out;
        }
        
        /* Force landscape on mobile */
        @media screen and (max-width: 768px) and (orientation: portrait) {
            body::before {
                content: "Please rotate your device to landscape mode";
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: #000;
                color: #fff;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                font-size: 24px;
                text-align: center;
                padding: 20px;
            }
            
            #gameContainer {
                display: none;
            }
        }
        
        /* Mobile Controls - Overlay Style */
        .mobile-controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            pointer-events: none;
            z-index: 1000;
        }
        
        .mobile-controls.show {
            display: block;
        }
        
        .touch-button {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            transition: none;
        }
        
        .touch-button.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.8);
            transform: scale(0.9);
        }
        
        /* Virtual Joystick */
        .virtual-joystick {
            position: absolute;
            left: 60px;
            bottom: 30px; /* Moved lower from 60px */
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        
        .joystick-base {
            position: absolute;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }
        
        .joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: none;
        }
        
        
        /* Action Buttons */
        .action-buttons {
            position: absolute;
            right: 60px;
            bottom: 40px;
            width: 280px;
            height: 200px;
            pointer-events: none;
        }
        
        .action-button {
            width: 70px;
            height: 70px;
            font-size: 18px;
        }
        
        /* 2-button layout optimized for mobile */
        .btn-punch { 
            position: absolute;
            bottom: 20px;
            left: 50px; /* Moved closer to center from 20px */
        }
        .btn-kick { 
            position: absolute;
            bottom: 20px;
            right: 50px; /* Moved closer to center from 20px */
        }
        
        @media (max-width: 768px) {
            .controls {
                display: none;
            }
            
            #gameContainer {
                width: 100vw;
                height: 100vh;
            }
            
            canvas {
                width: 100% !important;
                height: 100% !important;
                object-fit: contain;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="combo-display" id="comboDisplay"></div>
        <div class="controls">
            Movement: A/D (walk), S (crouch), W+A/D (jump) | Punch: U/I/O | Kick: J/K/L | Throw: I+K | Block: Hold back<br>
            Elon: Flamethrower ↓↘→ + Punch | Trump: Hadouken ↓↘→ + Punch | Shoryuken: →↓↘ + Punch | Tatsumaki: ↓↙← + Kick
        </div>
        
        <!-- Mobile Controls -->
        <div class="mobile-controls" id="mobileControls">
            <!-- Virtual Joystick for movement -->
            <div class="virtual-joystick" id="virtualJoystick">
                <div class="joystick-base"></div>
                <div class="joystick-handle" id="joystickHandle"></div>
            </div>
            
            <!-- Action Buttons -->
            <div class="action-buttons">
                <div class="touch-button action-button btn-punch" data-key="u">PUNCH</div>
                <div class="touch-button action-button btn-kick" data-key="j">KICK</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Base game dimensions
        const BASE_WIDTH = 960;
        const BASE_HEIGHT = 540;
        let gameScale = 1;
        
        // Responsive canvas sizing
        function resizeCanvas() {
            // Get available space accounting for safe areas and canvas border
            const borderWidth = 8; // 4px border on each side
            const availableWidth = window.innerWidth - 
                parseInt(getComputedStyle(document.body).paddingLeft) - 
                parseInt(getComputedStyle(document.body).paddingRight) - 
                borderWidth;
            const availableHeight = window.innerHeight - 
                parseInt(getComputedStyle(document.body).paddingTop) - 
                parseInt(getComputedStyle(document.body).paddingBottom) - 
                borderWidth;
            
            // For landscape mode, fill the entire screen instead of maintaining aspect ratio
            const isLandscape = window.innerWidth > window.innerHeight;
            
            let finalWidth, finalHeight;
            
            if (isLandscape) {
                // In landscape, use full available space
                finalWidth = availableWidth * 0.98; // 98% to prevent edge clipping
                finalHeight = availableHeight * 0.98;
                
                // Calculate scale based on the dimensions
                const scaleX = finalWidth / BASE_WIDTH;
                const scaleY = finalHeight / BASE_HEIGHT;
                gameScale = Math.max(scaleX, scaleY); // Use max to fill screen
            } else {
                // In portrait, maintain aspect ratio (fallback for unsupported orientation)
                const scaleX = availableWidth / BASE_WIDTH;
                const scaleY = availableHeight / BASE_HEIGHT;
                gameScale = Math.min(scaleX, scaleY) * 0.95;
                finalWidth = BASE_WIDTH * gameScale;
                finalHeight = BASE_HEIGHT * gameScale;
            }
            
            // Apply scale
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            canvas.style.width = finalWidth + 'px';
            canvas.style.height = finalHeight + 'px';
            
            // Center the canvas
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.style.position = 'absolute';
            gameContainer.style.left = '50%';
            gameContainer.style.top = '50%';
            gameContainer.style.transform = 'translate(-50%, -50%)';
            
            // Re-enable image smoothing after resize
            ctx.imageSmoothingEnabled = false;
        }
        
        // Initial resize
        resizeCanvas();
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        
        // Also resize when the page becomes visible (for home screen apps)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                setTimeout(resizeCanvas, 100);
            }
        });

        // Background image
        const backgroundImage = new Image();
        backgroundImage.src = 'ChatGPT Image Jul 31, 2025, 08_46_53 PM.png';
        let backgroundLoaded = false;
        backgroundImage.onload = () => {
            backgroundLoaded = true;
        };
        
        // Cash image for Trump's money throw
        const cashImage = new Image();
        cashImage.src = 'trump1/cash.png';
        let cashLoaded = false;
        cashImage.onload = () => {
            cashLoaded = true;
        };

        // Global effects
        let screenShake = 0;
        let hitPause = 0;
        let globalFreeze = 0;
        let comboCounter = 0;
        let comboTimer = 0;
        let particles = [];
        let afterImages = [];
        
        // Testing toggle
        let aiAttackDisabled = false;  // Toggle for disabling AI attacks (press '1')

        // Constants
        const GROUND_Y = 440;
        const GRAVITY = 0.8;
        const WALK_SPEED_FORWARD = 3.5;
        const WALK_SPEED_BACKWARD = 2.8;
        const JUMP_VELOCITY_Y = -22;  // Increased from -16 for higher jumps
        const JUMP_VELOCITY_X = 5.5;
        const THROW_RANGE = 75;  // Increased from 60 to make throws more consistent
        
        // Debug sprite positioning - adjust these values if sprites float or sink
        let SPRITE_DEBUG_MODE = false;  // Set to true to show sprite bounds
        let HITBOX_DEBUG_MODE = false;   // Set to true to visualize hitboxes and hurtboxes
        let SPRITE_Y_OFFSET = 54;  // Correct offset for sprite positioning
        const THROW_TECH_WINDOW = 7;

        // Sprite Manager - handles loading and caching character sprites
        class SpriteManager {
            constructor() {
                this.sprites = {};
                this.loaded = false;
                this.loadingPromises = [];
                
                // Sprite mappings for different characters
                this.spriteMappings = {
                    'elon': {
                        basePath: 'elon/Elon1_normalized_v3/',
                        sprites: {
                            'idle': 'standing.png',
                            'walk': 'walking1.png',  // First frame of walk cycle
                            'walk2': 'walking2.png', // Second frame
                            'walk3': 'walking3.png', // Third frame
                            'crouch': 'crouch.png',  // Now we have a crouch sprite!
                            'jump': 'jump-elon.png',
                            'punch': 'punch.png',  // Standing punch
                            'punch2': 'punch2.png', // Alternative punch
                            'P': 'punch.png',  // Alias for move
                            'P2': 'punch2.png', // Alias for move
                            'K': 'kick-elon.png',   // Standing kick
                            'kick-standing': 'kick-elon.png',  // Alias
                            'crP': 'crouch-punch.png', // Crouch punch
                            'crK': 'crouch-kick.png',  // Crouch kick
                            'jP': 'jumppunch-elon.png',    // Jump punch
                            'jK': 'jump-kick.png',     // Jump kick
                            'block': 'block.png',
                            'crouch-block': 'crouch-block.png',  // Crouch blocking sprite
                            'hit': 'hit.png',  // New hit sprite!
                            'knockdown': 'thrown.png',  // Using thrown as knockdown
                            'beingThrown': 'thrown.png',
                            'throwingOpponent': 'punch2.png',  // Using punch2 for throw
                            'dizzy': 'hit.png',  // Use hit sprite for dizzy
                            'hitstun': 'hit.png',  // Use hit sprite for hitstun
                            'hadouken': 'powermove-1.png',  // Flamethrower sprite
                            'flamethrower': 'powermove-1.png'  // Alias
                        }
                    },
                    'trump': {
                        basePath: 'trump1_normalized_v3/',
                        sprites: {
                            'idle': 'standing.png',
                            'walk': 'walking-forward.png',  // Use the new walking sprite
                            'walk2': 'standing.png',  // Alternate frame for walk animation
                            'crouch': 'crouch.png',
                            'jump': 'jump.png',
                            'punch': 'punch-standing.png',  // Standing punch
                            'P': 'punch-standing.png',  // Alias for move
                            'K': 'kick-standing.png',   // Standing kick
                            'kick-standing': 'kick-standing.png',  // Alias
                            'crP': 'crouch-punch.png', // Crouch punch
                            'crK': 'crouch-kick.png',  // Crouch kick
                            'jP': 'jump.png',    // Use jump sprite for jump punch
                            'jK': 'jump-kick.png',     // Jump kick
                            'block': 'crouch-block.png',
                            'hit': 'hit.png',  // Now Trump has a hit sprite too!
                            'knockdown': 'thrown.png',  // Use thrown sprite for knockdown
                            'beingThrown': 'thrown.png',
                            'dizzy': 'hit.png',  // Use hit for dizzy
                            'hitstun': 'hit.png',  // Use hit for hitstun
                            'hadouken': 'punch-standing.png'  // Use punch sprite for hadouken
                        }
                    }
                };
                
                // Sprite scaling and positioning data
                this.spriteConfig = {
                    scale: 0.41,  // Default sprite scale
                    anchorY: 0.95,  // Anchor point near feet (95% from top)
                    get offsetY() { return SPRITE_Y_OFFSET; },  // Use global offset for easy debugging
                    defaultWidth: 64,  // Expected sprite width
                    defaultHeight: 64  // Expected sprite height
                };
                
                // Debug mode for adjusting sprites
                this.debug = false;
            }
            
            async loadCharacterSprites(characterName) {
                const mapping = this.spriteMappings[characterName];
                if (!mapping) {
                    console.warn(`No sprite mapping for character: ${characterName}`);
                    return;
                }
                
                const promises = [];
                
                for (const [state, filename] of Object.entries(mapping.sprites)) {
                    const path = mapping.basePath + filename;
                    const key = `${characterName}_${state}`;
                    
                    // Don't reload if already loading or loaded
                    if (this.sprites[key]) continue;
                    
                    const promise = this.loadSprite(key, path);
                    promises.push(promise);
                }
                
                await Promise.all(promises);
                console.log(`[SPRITES] Loaded sprites for ${characterName}`);
            }
            
            async loadSprite(key, path) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    
                    img.onload = () => {
                        this.sprites[key] = img;
                        console.log(`[SPRITES] Loaded: ${key} (${img.width}x${img.height})`);
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        console.error(`[SPRITES] Failed to load: ${path}`);
                        reject(new Error(`Failed to load sprite: ${path}`));
                    };
                    
                    img.src = path;
                });
            }
            
            getSprite(characterName, state) {
                const key = `${characterName}_${state}`;
                return this.sprites[key];
            }
            
            drawSprite(ctx, characterName, state, x, y, facing = 1, rotation = 0) {
                const sprite = this.getSprite(characterName, state);
                
                if (!sprite) {
                    // console.log(`[SPRITE] Missing sprite: ${characterName}_${state}`);
                    return false;
                }
                
                ctx.save();
                
                // Get actual sprite dimensions
                const spriteWidth = sprite.width;
                const spriteHeight = sprite.height;
                
                // Apply scale to find scaled dimensions
                const scaledHeight = spriteHeight * this.spriteConfig.scale;
                const scaledWidth = spriteWidth * this.spriteConfig.scale;
                
                // Position at character location (feet position)
                // We need to draw the sprite ABOVE the ground position
                ctx.translate(x, y);
                
                // Apply rotation if any (for throws)
                if (rotation !== 0) {
                    ctx.rotate(rotation);
                }
                
                // Apply scale
                ctx.scale(this.spriteConfig.scale, this.spriteConfig.scale);
                
                // Flip horizontally if facing left
                if (facing === -1) {
                    ctx.scale(-1, 1);
                    if (SPRITE_DEBUG_MODE) {
                        console.log(`[SPRITE] Flipping sprite for ${characterName}, state: ${state}, facing: ${facing}`);
                    }
                }
                
                // Draw sprite - sprites are already normalized, so just center them
                const drawX = -spriteWidth / 2;
                const drawY = -spriteHeight + this.spriteConfig.offsetY / this.spriteConfig.scale;
                
                ctx.drawImage(sprite, drawX, drawY);
                
                // Debug mode - show sprite bounds and ground line
                if (SPRITE_DEBUG_MODE) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(drawX, drawY, spriteWidth, spriteHeight);
                    
                    // Show character position (feet)
                    ctx.fillStyle = 'lime';
                    ctx.fillRect(-2, -2, 4, 4);
                    
                    // Show actual sprite dimensions
                    ctx.fillStyle = 'yellow';
                    ctx.font = '12px monospace';
                    ctx.fillText(`${spriteWidth}x${spriteHeight}`, drawX, drawY - 5);
                    
                    // Reset transform to draw ground line
                    ctx.restore();
                    ctx.save();
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x - 50, y);
                    ctx.lineTo(x + 50, y);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                return true;
            }
        }
        
        // Create global sprite manager
        const spriteManager = new SpriteManager();

        // Input Manager - handles keyboard, touch, and gamepad inputs
        class InputManager {
            constructor() {
                this.keys = {};
                this.touches = new Map();
                this.gamepads = [];
                this.lastGamepadState = new Map();
                this.player = null; // Will be set after player is created
                this.lastDirections = { left: false, right: false, up: false, down: false };
                
                // Touch control detection
                this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                
                // Initialize
                this.setupKeyboard();
                this.setupTouch();
                this.setupGamepad();
                
                // Show mobile controls if on mobile device
                if (this.isMobile) {
                    document.getElementById('mobileControls').classList.add('show');
                }
            }
            
            setPlayer(player) {
                this.player = player;
            }
            
            setupKeyboard() {
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    this.keys[key] = true;
                    
                    // Restart game on ESC
                    if (key === 'escape' && window.gameOver) {
                        location.reload();
                    }
                    
                    // Toggle AI attacks with '1' key
                    if (key === '1') {
                        aiAttackDisabled = !aiAttackDisabled;
                        console.log('[DEBUG] AI attacks:', aiAttackDisabled ? 'DISABLED' : 'ENABLED');
                    }
                    
                    // Toggle hitbox visualization with 'h' key
                    if (key === 'h' || key === 'H') {
                        HITBOX_DEBUG_MODE = !HITBOX_DEBUG_MODE;
                        console.log('[DEBUG] Hitbox visualization:', HITBOX_DEBUG_MODE ? 'ON' : 'OFF');
                    }
                    
                    // Sprite scale adjustment with +/- keys
                    if (key === '=' || key === '+') {
                        spriteManager.spriteConfig.scale += 0.05;
                        console.log('[SPRITES] Scale increased to:', spriteManager.spriteConfig.scale);
                    }
                    if (key === '-' || key === '_') {
                        spriteManager.spriteConfig.scale = Math.max(0.05, spriteManager.spriteConfig.scale - 0.05);
                        console.log('[SPRITES] Scale decreased to:', spriteManager.spriteConfig.scale);
                    }
                    
                    // Sprite Y offset adjustment with 9/0 keys
                    if (key === '9') {
                        SPRITE_Y_OFFSET -= 2;
                        console.log('[SPRITES] Y Offset:', SPRITE_Y_OFFSET);
                    }
                    if (key === '0') {
                        SPRITE_Y_OFFSET += 2;
                        console.log('[SPRITES] Y Offset:', SPRITE_Y_OFFSET);
                    }
                    
                    // Toggle sprite debug mode with 8 key
                    if (key === '8') {
                        SPRITE_DEBUG_MODE = !SPRITE_DEBUG_MODE;
                        console.log('[SPRITES] Debug mode:', SPRITE_DEBUG_MODE ? 'ON' : 'OFF');
                    }
                    
                    e.preventDefault();
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    e.preventDefault();
                });
            }
            
            setupTouch() {
                if (!this.isMobile) return;
                
                // Virtual Joystick handling
                const joystick = document.getElementById('virtualJoystick');
                const joystickHandle = document.getElementById('joystickHandle');
                let joystickTouch = null;
                
                const updateJoystick = (touch) => {
                    const rect = joystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let deltaX = touch.clientX - centerX;
                    let deltaY = touch.clientY - centerY;
                    
                    // Limit to circle
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = rect.width / 2 - 30;
                    
                    if (distance > maxDistance) {
                        deltaX = (deltaX / distance) * maxDistance;
                        deltaY = (deltaY / distance) * maxDistance;
                    }
                    
                    // Update visual position
                    joystickHandle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                    
                    // Update input states
                    const threshold = 30;
                    this.keys['a'] = deltaX < -threshold;
                    this.keys['d'] = deltaX > threshold;
                    this.keys['s'] = deltaY > threshold;
                    this.keys['w'] = deltaY < -threshold;  // Up for jump
                };
                
                const resetJoystick = () => {
                    joystickHandle.style.transform = 'translate(-50%, -50%)';
                    this.keys['a'] = false;
                    this.keys['d'] = false;
                    this.keys['s'] = false;
                    this.keys['w'] = false;
                };
                
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!joystickTouch && e.changedTouches.length > 0) {
                        joystickTouch = e.changedTouches[0].identifier;
                        updateJoystick(e.changedTouches[0]);
                    }
                }, {passive: false});
                
                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    for (let touch of e.changedTouches) {
                        if (touch.identifier === joystickTouch) {
                            updateJoystick(touch);
                        }
                    }
                }, {passive: false});
                
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    for (let touch of e.changedTouches) {
                        if (touch.identifier === joystickTouch) {
                            joystickTouch = null;
                            resetJoystick();
                        }
                    }
                }, {passive: false});
                
                joystick.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    joystickTouch = null;
                    resetJoystick();
                }, {passive: false});
                
                // Regular button handling
                const handleTouchStart = (e) => {
                    e.preventDefault();
                    const button = e.target;
                    if (button.dataset.key) {
                        this.keys[button.dataset.key] = true;
                        button.classList.add('active');
                        
                        // Store touch for tracking
                        for (let touch of e.changedTouches) {
                            this.touches.set(touch.identifier, button);
                        }
                    }
                };
                
                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    for (let touch of e.changedTouches) {
                        const button = this.touches.get(touch.identifier);
                        if (button && button.dataset.key) {
                            this.keys[button.dataset.key] = false;
                            button.classList.remove('active');
                            this.touches.delete(touch.identifier);
                        }
                    }
                };
                
                const handleTouchMove = (e) => {
                    e.preventDefault();
                    for (let touch of e.changedTouches) {
                        const element = document.elementFromPoint(touch.clientX, touch.clientY);
                        const oldButton = this.touches.get(touch.identifier);
                        
                        if (oldButton && element !== oldButton) {
                            // Moved to different button
                            if (oldButton.dataset.key) {
                                this.keys[oldButton.dataset.key] = false;
                                oldButton.classList.remove('active');
                            }
                            
                            if (element && element.dataset.key) {
                                this.keys[element.dataset.key] = true;
                                element.classList.add('active');
                                this.touches.set(touch.identifier, element);
                            }
                        }
                    }
                };
                
                const mobileControls = document.getElementById('mobileControls');
                mobileControls.addEventListener('touchstart', handleTouchStart, {passive: false});
                mobileControls.addEventListener('touchend', handleTouchEnd, {passive: false});
                mobileControls.addEventListener('touchmove', handleTouchMove, {passive: false});
                mobileControls.addEventListener('touchcancel', handleTouchEnd, {passive: false});
            }
            
            setupGamepad() {
                // Check for gamepads on connect/disconnect
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected:', e.gamepad.id);
                });
            }
            
            updateGamepads() {
                // Get current gamepad states
                this.gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                
                for (let i = 0; i < this.gamepads.length; i++) {
                    const gamepad = this.gamepads[i];
                    if (!gamepad) continue;
                    
                    const lastState = this.lastGamepadState.get(i) || {};
                    const currentState = {};
                    
                    // D-pad or left stick for movement
                    const leftX = gamepad.axes[0];
                    const leftY = gamepad.axes[1];
                    const deadzone = 0.3;
                    
                    // Left stick / D-pad mapping
                    if (leftX < -deadzone || gamepad.buttons[14]?.pressed) { // Left
                        this.keys['a'] = true;
                    } else if (!this.keys['a'] || (!gamepad.buttons[14]?.pressed && lastState.left)) {
                        this.keys['a'] = false;
                    }
                    
                    if (leftX > deadzone || gamepad.buttons[15]?.pressed) { // Right
                        this.keys['d'] = true;
                    } else if (!this.keys['d'] || (!gamepad.buttons[15]?.pressed && lastState.right)) {
                        this.keys['d'] = false;
                    }
                    
                    if (leftY < -deadzone || gamepad.buttons[12]?.pressed) { // Up
                        this.keys['w'] = true;
                    } else if (!this.keys['w'] || (!gamepad.buttons[12]?.pressed && lastState.up)) {
                        this.keys['w'] = false;
                    }
                    
                    if (leftY > deadzone || gamepad.buttons[13]?.pressed) { // Down
                        this.keys['s'] = true;
                    } else if (!this.keys['s'] || (!gamepad.buttons[13]?.pressed && lastState.down)) {
                        this.keys['s'] = false;
                    }
                    
                    // Button mapping (Xbox/PS5 compatible) - 4 BUTTON SYSTEM
                    // X/Square = LP, Y/Triangle = HP
                    // A/X = LK, B/Circle = HK
                    
                    const buttonMap = {
                        0: 'j',  // A/X button -> LK
                        1: 'k',  // B/Circle -> HK
                        2: 'u',  // X/Square -> LP
                        3: 'i',  // Y/Triangle -> HP
                        4: 'u',  // LB/L1 -> LP (alternative)
                        5: 'i',  // RB/R1 -> HP (alternative)
                        6: 'j',  // LT/L2 -> LK (alternative)
                        7: 'k'   // RT/R2 -> HK (alternative)
                    };
                    
                    // Update button states
                    for (let btnIndex in buttonMap) {
                        const key = buttonMap[btnIndex];
                        if (gamepad.buttons[btnIndex]?.pressed) {
                            this.keys[key] = true;
                        } else if (lastState[`btn${btnIndex}`]) {
                            this.keys[key] = false;
                        }
                        currentState[`btn${btnIndex}`] = gamepad.buttons[btnIndex]?.pressed;
                    }
                    
                    // Store current state
                    currentState.left = leftX < -deadzone || gamepad.buttons[14]?.pressed;
                    currentState.right = leftX > deadzone || gamepad.buttons[15]?.pressed;
                    currentState.up = leftY < -deadzone || gamepad.buttons[12]?.pressed;
                    currentState.down = leftY > deadzone || gamepad.buttons[13]?.pressed;
                    
                    // Track directional changes and add to input buffer for special moves
                    if (this.player && this.player.inputBuffer) {
                        const facing = this.player.facing || 1;
                        let addedDirection = null;
                        
                        // Check for directional changes
                        if (currentState.down && !this.lastDirections.down) {
                            this.player.inputBuffer.addDirection('2');
                            addedDirection = '2';
                        }
                        if (currentState.up && !this.lastDirections.up) {
                            this.player.inputBuffer.addDirection('8');
                            addedDirection = '8';
                        }
                        
                        // Handle left/right based on facing
                        if (facing === 1) {
                            if (currentState.left && !this.lastDirections.left) {
                                this.player.inputBuffer.addDirection('4');
                                addedDirection = '4';
                            }
                            if (currentState.right && !this.lastDirections.right) {
                                this.player.inputBuffer.addDirection('6');
                                addedDirection = '6';
                            }
                        } else {
                            // Reversed when facing left
                            if (currentState.left && !this.lastDirections.left) {
                                this.player.inputBuffer.addDirection('6');
                                addedDirection = '6';
                            }
                            if (currentState.right && !this.lastDirections.right) {
                                this.player.inputBuffer.addDirection('4');
                                addedDirection = '4';
                            }
                        }
                        
                        // Handle diagonals - always add current diagonal state
                        if (currentState.down && currentState.right) {
                            const dir = facing === 1 ? '3' : '1';
                            // Add direction if it changed or every few frames while holding
                            if (!this.lastDirections.down || !this.lastDirections.right || 
                                (this.player.inputBuffer.directions.length === 0 || 
                                 this.player.inputBuffer.directions[this.player.inputBuffer.directions.length - 1].dir !== dir)) {
                                this.player.inputBuffer.addDirection(dir);
                                addedDirection = dir;
                            }
                        } else if (currentState.down && currentState.left) {
                            const dir = facing === 1 ? '1' : '3';
                            if (!this.lastDirections.down || !this.lastDirections.left ||
                                (this.player.inputBuffer.directions.length === 0 || 
                                 this.player.inputBuffer.directions[this.player.inputBuffer.directions.length - 1].dir !== dir)) {
                                this.player.inputBuffer.addDirection(dir);
                                addedDirection = dir;
                            }
                        } else if (currentState.up && currentState.right) {
                            const dir = facing === 1 ? '9' : '7';
                            if (!this.lastDirections.up || !this.lastDirections.right ||
                                (this.player.inputBuffer.directions.length === 0 || 
                                 this.player.inputBuffer.directions[this.player.inputBuffer.directions.length - 1].dir !== dir)) {
                                this.player.inputBuffer.addDirection(dir);
                                addedDirection = dir;
                            }
                        } else if (currentState.up && currentState.left) {
                            const dir = facing === 1 ? '7' : '9';
                            if (!this.lastDirections.up || !this.lastDirections.left ||
                                (this.player.inputBuffer.directions.length === 0 || 
                                 this.player.inputBuffer.directions[this.player.inputBuffer.directions.length - 1].dir !== dir)) {
                                this.player.inputBuffer.addDirection(dir);
                                addedDirection = dir;
                            }
                        }
                        
                        // Debug logging for gamepad inputs
                        if (addedDirection && this.player.isPlayer) {
                            const recentDirs = this.player.inputBuffer.directions
                                .slice(-6)
                                .map(d => d.dir)
                                .join('');
                            console.log('[GAMEPAD] Input:', addedDirection, '| Buffer:', recentDirs, '| Facing:', facing === 1 ? 'RIGHT' : 'LEFT');
                            
                            // Check for special moves and provide helpful feedback
                            if (recentDirs.includes('236')) {
                                console.log('[GAMEPAD] ✓ Hadouken motion detected! Now press any PUNCH button (X/Square, Y/Triangle, or RB/R1)');
                            }
                            if (recentDirs.includes('623')) {
                                console.log('[GAMEPAD] ✓ Shoryuken motion detected! Now press any PUNCH button (X/Square, Y/Triangle, or RB/R1)');
                            }
                            if (recentDirs.includes('214')) {
                                console.log('[GAMEPAD] ✓ Tatsumaki motion detected! Now press any KICK button (A/X, B/Circle, or RT/R2)');
                            }
                            
                            // Help user understand the motions
                            if (recentDirs.includes('241')) {
                                console.log('[GAMEPAD] Tip: You did quarter-circle BACK. For Hadouken, do quarter-circle FORWARD (down, down-forward, forward)');
                            }
                            if (recentDirs.includes('263')) {
                                console.log('[GAMEPAD] Tip: You did quarter-circle FORWARD. For Tatsumaki, do quarter-circle BACK (down, down-back, back)');
                            }
                            
                            // Check if they're close to a special move
                            if (recentDirs.includes('21') || recentDirs.includes('23')) {
                                console.log('[GAMEPAD] Tip: Almost Hadouken! Complete with forward (→) + punch');
                            }
                            if (recentDirs.includes('62')) {
                                console.log('[GAMEPAD] Tip: Almost Shoryuken! Complete with down-forward (↘) + punch');
                            }
                        }
                        
                        // Update last directions
                        this.lastDirections = {
                            left: currentState.left,
                            right: currentState.right,
                            up: currentState.up,
                            down: currentState.down
                        };
                    }
                    
                    this.lastGamepadState.set(i, currentState);
                }
            }
            
            getKeys() {
                // Update gamepad states
                this.updateGamepads();
                
                // Return combined input state
                return this.keys;
            }
            
            isPressed(key) {
                return this.keys[key] || false;
            }
        }

        // Particle system
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1;
                this.maxLife = 1;
                
                switch(type) {
                    case 'hit':
                        this.vx = (Math.random() - 0.5) * 15;
                        this.vy = (Math.random() - 0.5) * 15;
                        this.size = Math.random() * 4 + 2;
                        this.color = `hsl(${Math.random() * 60}, 100%, 70%)`;
                        this.maxLife = 20;
                        break;
                    case 'block':
                        this.vx = (Math.random() - 0.5) * 8;
                        this.vy = -Math.random() * 8;
                        this.size = Math.random() * 3 + 1;
                        this.color = '#00ccff';
                        this.maxLife = 15;
                        break;
                    case 'dust':
                        this.vx = (Math.random() - 0.5) * 4;
                        this.vy = -Math.random() * 2;
                        this.size = Math.random() * 6 + 4;
                        this.color = 'rgba(139, 69, 19, 0.4)';
                        this.maxLife = 25;
                        break;
                    case 'fire':
                        this.vx = (Math.random() - 0.5) * 3;
                        this.vy = -Math.random() * 5 - 2;
                        this.size = Math.random() * 8 + 4;
                        this.color = `hsl(${Math.random() * 60}, 100%, 50%)`;
                        this.maxLife = 30;
                        break;
                }
                this.life = this.maxLife;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                
                if (this.type === 'dust' || this.type === 'fire') {
                    this.vy += 0.2;
                    this.vx *= 0.98;
                }
                
                if (this.type === 'hit') {
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                }
            }

            draw() {
                ctx.save();
                const alpha = this.life / this.maxLife;
                
                if (this.type === 'fire') {
                    // Fire gradient
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                    gradient.addColorStop(0, `hsla(60, 100%, 90%, ${alpha})`);
                    gradient.addColorStop(0.5, `hsla(30, 100%, 60%, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `hsla(0, 100%, 40%, ${alpha * 0.4})`);
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = alpha;
                }
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.type === 'hit') {
                    // Add glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // After image for motion trails
        class AfterImage {
            constructor(x, y, fighter) {
                this.x = x;
                this.y = y;
                this.fighter = fighter;
                this.opacity = 0.5;
                this.state = fighter.state;
                this.currentMove = fighter.currentMove;
                this.animFrame = fighter.animFrame;
                this.facing = fighter.facing;
                this.crouching = fighter.crouching;
            }

            update() {
                this.opacity -= 0.05;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                // Draw a simplified version of the fighter
                const tempX = this.fighter.x;
                const tempY = this.fighter.y;
                this.fighter.x = this.x;
                this.fighter.y = this.y;
                this.fighter.drawCharacterSprite(true);
                this.fighter.x = tempX;
                this.fighter.y = tempY;
                ctx.restore();
            }
        }

        // Enhanced Fighter class
        class Fighter {
            constructor(x, isPlayer, characterName = 'elon') {
                this.x = x;
                this.y = GROUND_Y;
                this.isPlayer = isPlayer;
                this.facing = isPlayer ? 1 : -1;
                
                // Character identity for sprites
                this.characterName = characterName;
                
                // Punch variety counter
                this.punchCount = 0;
                
                // Physics
                this.velocityX = 0;
                this.velocityY = 0;
                this.pushbackVelocity = 0;
                this.jumpDirection = 0;
                
                // States
                this.state = 'idle';
                this.crouching = false;
                this.blocking = false;
                this.grounded = true;
                
                // Combat
                this.health = 100;
                this.maxHealth = 100;
                this.stunMeter = 0;
                this.maxStun = 40;
                this.isDizzy = false;
                this.superMeter = 0;
                this.maxSuper = 100;
                
                // Animation
                this.animFrame = 0;
                this.animTimer = 0;
                this.spriteFrame = 0;
                this.breathingOffset = 0;
                
                // Throw cooldown
                this.throwCooldown = 0;
                this.throwButtonsPressed = false;  // Track if throw buttons are held
                
                // Throw animation state
                this.beingThrown = false;
                this.throwAttacker = null;
                this.throwAnimationFrame = 0;
                
                // Move state
                this.currentMove = null;
                this.moveFrame = 0;
                this.hitstunFrames = 0;
                this.blockstunFrames = 0;
                this.knockdownFrames = 0;
                this.invincibleFrames = 0;
                this.rotation = 0;  // For throw spinning
                
                // Color scheme
                this.skinColor = isPlayer ? '#f4c2a1' : '#f4c2a1';
                this.giColor = isPlayer ? '#ffffff' : '#ff3333';
                this.pantsColor = isPlayer ? '#ff7f50' : '#4169e1';
                this.hairColor = isPlayer ? '#8b6f47' : '#2f4f4f';
                this.beltColor = '#8b4513';
                
                // Effects
                this.glowIntensity = 0;
                this.auraActive = false;
                
                // Input
                this.inputBuffer = new InputBuffer();
                this.projectiles = [];
                
                // Hitboxes
                this.hurtboxes = [];
                this.hitboxes = [];
                
                // Multi-hit tracking
                this.currentMoveHits = 0;
                this.lastHitFrame = -999;
                
                // Depth switch tracking
                this.depthSwitchTimer = 0;
                this.depthSwitchProgress = 0; // 0 to 1 for smooth transitions
                
                // Sprite transition tracking
                this.previousSprite = 'idle';
                this.spriteTransitionTimer = 0;
                this.spriteTransitionFrom = null;
                this.spriteTransitionTo = null;
            }

            drawCharacterSprite(isAfterImage = false) {
                ctx.save();
                
                // Breathing animation
                if (!isAfterImage && this.state === 'idle') {
                    this.breathingOffset = Math.sin(this.animTimer * 0.05) * 2;
                }
                
                // Apply depth switch smoothing effects
                if (!isAfterImage && this.depthSwitchTimer > 0) {
                    // Calculate progress (0 to 1 and back to 0)
                    const totalFrames = 10; // Total animation frames
                    const halfFrames = totalFrames / 2;
                    if (this.depthSwitchTimer > halfFrames) {
                        // Fading in
                        this.depthSwitchProgress = 1 - ((this.depthSwitchTimer - halfFrames) / halfFrames);
                    } else {
                        // Fading out
                        this.depthSwitchProgress = this.depthSwitchTimer / halfFrames;
                    }
                    
                    // 1. Subtle opacity change
                    const baseOpacity = 0.9;
                    const maxOpacity = 1.0;
                    ctx.globalAlpha = baseOpacity + (this.depthSwitchProgress * (maxOpacity - baseOpacity));
                    
                    // 2. Position interpolation (move slightly forward)
                    const moveAmount = this.depthSwitchProgress * 5;
                    ctx.translate(this.facing * moveAmount, 0);
                    
                    // 3. Removed motion blur effect
                }
                
                // Apply rotation for throw animation only when being thrown
                if (this.rotation !== 0 && this.state === 'beingThrown') {
                    ctx.translate(this.x, this.y - 50);
                    ctx.rotate(this.rotation);
                    ctx.translate(-this.x, -(this.y - 50));
                } else if (this.rotation !== 0) {
                    // Clean up any stuck rotation
                    this.rotation = 0;
                }
                
                // Note: Flipping is handled inside spriteManager.drawSprite
                // so we don't need to do it here for sprites
                
                // Shadow
                if (!isAfterImage) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(this.x, GROUND_Y + 5, 40, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Invincibility flash
                if (this.invincibleFrames > 0 && !isAfterImage) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffff00';
                }
                
                
                // Draw based on state
                const baseY = this.y + this.breathingOffset;
                
                // Try to use sprites first if available
                if (this.characterName) {
                    let spriteState = null;
                    let useSprite = true;
                    
                    // Map game states to sprite states
                    if (this.state === 'knockdown' || this.knockdownFrames > 0) {
                        spriteState = 'knockdown';
                    } else if (this.state === 'beingThrown') {
                        spriteState = 'beingThrown';
                    } else if (this.state === 'throwingOpponent') {
                        spriteState = 'throwingOpponent';  // Use throwing opponent sprite
                    } else if (!this.grounded && this.state === 'attack') {
                        // Jumping attacks
                        if (this.currentMove === 'jP') {
                            spriteState = 'jP';
                        } else if (this.currentMove === 'jK') {
                            spriteState = 'jK';
                        } else {
                            spriteState = 'jump';
                        }
                    } else if (!this.grounded) {
                        spriteState = 'jump';
                    } else if (this.state === 'attack' && this.currentMove) {
                        // Handle special moves - only if we're actually in attack state AND have a move
                        if (this.currentMove === 'hadouken') {
                            spriteState = 'hadouken';  // Use special hadouken/flamethrower sprite
                        } else if (this.currentMove === 'shoryuken') {
                            spriteState = 'jP';  // Use jump punch for shoryuken
                        } else if (this.currentMove === 'tatsumaki') {
                            spriteState = 'jK';  // Use jump kick for tatsumaki
                        } else if (this.currentMove) {
                            // Handle punch cycling for variety
                            if (this.currentMove === 'P' && this.characterName === 'elon') {
                                // Alternate between punch sprites
                                spriteState = (this.punchCount % 2 === 0) ? 'punch' : 'punch2';
                            } else {
                                // Direct mapping - move names should match sprite keys
                                spriteState = this.currentMove;
                            }
                        } else {
                            spriteState = 'idle';
                        }
                    } else if (this.state === 'walk') {
                        // Animated walk cycle
                        if (this.characterName === 'elon') {
                            // 3-frame walk cycle for Elon
                            const walkCycleFrame = Math.floor(this.animTimer / 6) % 3;
                            
                            // Cycle through walk -> walk2 -> walk3
                            if (walkCycleFrame === 0) {
                                spriteState = 'walk';  // walking1.png
                            } else if (walkCycleFrame === 1) {
                                spriteState = 'walk2'; // walking2.png
                            } else {
                                spriteState = 'walk3'; // walking3.png
                            }
                            
                            // Add a slight vertical bob for more natural movement
                            if (!isAfterImage) {
                                const bobAmount = Math.sin(this.animTimer * 0.2) * 1.5;
                                this.breathingOffset = bobAmount;
                            }
                        } else if (this.characterName === 'trump') {
                            // Create a smooth walk cycle
                            // Use a slower cycle for more natural walking
                            const walkCycleFrame = Math.floor(this.animTimer / 8) % 4;
                            
                            // Create a pattern: walk -> walk -> walk2 -> walk2
                            // This gives a nice rhythm with the step emphasized
                            if (walkCycleFrame < 2) {
                                spriteState = 'walk';  // Walking forward sprite
                            } else {
                                spriteState = 'walk2';  // Standing sprite
                            }
                            
                            // Add a slight vertical bob for more natural movement
                            if (!isAfterImage) {
                                const bobAmount = Math.sin(this.animTimer * 0.15) * 2;
                                this.breathingOffset = bobAmount;
                            }
                        } else {
                            spriteState = 'walk';
                        }
                    } else if (this.blocking && this.crouching) {
                        // Crouch blocking - check if sprite exists
                        if (this.characterName === 'elon') {
                            spriteState = 'crouch-block';  // Use special crouch-block sprite
                        } else {
                            spriteState = 'crouch';  // Fallback to crouch
                        }
                    } else if (this.state === 'crouch' || this.crouching) {
                        spriteState = 'crouch';
                    } else if (this.blocking) {
                        spriteState = 'block';
                    } else if (this.state === 'hitstun') {
                        spriteState = 'hitstun';
                    } else if (this.state === 'blockstun') {
                        spriteState = 'block';  // Use block sprite for blockstun
                    } else if (this.state === 'dizzy') {
                        spriteState = 'dizzy';
                    } else {
                        spriteState = 'idle';
                    }
                    
                    // Detect sprite transitions for interpolation
                    if (spriteState !== this.previousSprite && !isAfterImage) {
                        // Check if this is an attack transition we should interpolate
                        const isAttackTransition = 
                            (this.previousSprite === 'idle' && (spriteState === 'P' || spriteState === 'punch' || spriteState === 'punch2' || spriteState === 'K' || spriteState === 'cK' || spriteState === 'jK')) ||
                            ((this.previousSprite === 'P' || this.previousSprite === 'punch' || this.previousSprite === 'punch2' || this.previousSprite === 'K' || this.previousSprite === 'cK' || this.previousSprite === 'jK') && spriteState === 'idle');
                        
                        if (isAttackTransition) {
                            this.spriteTransitionFrom = this.previousSprite;
                            this.spriteTransitionTo = spriteState;
                            this.spriteTransitionTimer = 8; // 8 frames for smoother interpolation
                        }
                        this.previousSprite = spriteState;
                    }
                    
                    // Handle frame interpolation for transitions
                    if (this.spriteTransitionTimer > 0 && !isAfterImage && this.spriteTransitionFrom && this.spriteTransitionTo) {
                        const totalFrames = 8;
                        const progress = 1 - (this.spriteTransitionTimer / totalFrames);
                        
                        // Draw interpolated frames
                        ctx.save();
                        
                        // Draw the "from" sprite with decreasing opacity
                        ctx.globalAlpha = 1 - progress;
                        spriteManager.drawSprite(
                            ctx, 
                            this.characterName, 
                            this.spriteTransitionFrom, 
                            this.x, 
                            this.y,
                            this.facing,
                            0
                        );
                        
                        // Draw the "to" sprite with increasing opacity
                        ctx.globalAlpha = progress;
                        
                        // Add position offset for punches/kicks to simulate extension
                        let offsetX = 0;
                        if (this.spriteTransitionTo === 'P' || this.spriteTransitionTo === 'punch' || this.spriteTransitionTo === 'punch2') {
                            offsetX = Math.sin(progress * Math.PI * 0.5) * 3 * this.facing;
                        } else if (this.spriteTransitionTo === 'K' || this.spriteTransitionTo === 'cK' || this.spriteTransitionTo === 'jK') {
                            offsetX = Math.sin(progress * Math.PI * 0.5) * 5 * this.facing;
                        }
                        
                        spriteManager.drawSprite(
                            ctx, 
                            this.characterName, 
                            this.spriteTransitionTo, 
                            this.x + offsetX, 
                            this.y,
                            this.facing,
                            0
                        );
                        
                        ctx.restore();
                        
                        this.spriteTransitionTimer--;
                        
                        // Skip normal sprite drawing during transition
                        if (this.spriteTransitionTimer > 0) {
                            // Reset filters
                            ctx.filter = 'none';
                            ctx.globalAlpha = 1.0;
                            
                            // Dizzy stars still need to be drawn
                            if (this.isDizzy) {
                                ctx.fillStyle = '#ffff00';
                                ctx.font = 'bold 24px Arial';
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = '#ffff00';
                                for (let i = 0; i < 3; i++) {
                                    const angle = (this.animTimer * 0.1) + (i * Math.PI * 2 / 3);
                                    const starX = this.x + Math.cos(angle) * 30;
                                    const starY = baseY - 120 + Math.sin(angle) * 10;
                                    ctx.fillText('★', starX - 12, starY);
                                }
                            }
                            
                            // Reset filters before returning
                            ctx.filter = 'none';
                            ctx.globalAlpha = 1.0;
                            
                            ctx.restore();
                            return;
                        }
                    }
                    
                    // Continue with normal sprite drawing if not transitioning
                    if (useSprite && spriteState) {
                        // console.log(`[SPRITE ATTEMPT] Character: ${this.characterName}, State: ${this.state}, SpriteState: ${spriteState}, CurrentMove: ${this.currentMove}`);
                        const spriteDrawn = spriteManager.drawSprite(
                            ctx, 
                            this.characterName, 
                            spriteState, 
                            this.x, 
                            this.y,
                            this.facing,
                            this.state === 'beingThrown' ? this.rotation : 0
                        );
                        
                        // If sprite was drawn successfully, handle additional effects then return
                        if (spriteDrawn) {
                            // Dizzy stars still need to be drawn
                            if (this.isDizzy) {
                                ctx.fillStyle = '#ffff00';
                                ctx.font = 'bold 24px Arial';
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = '#ffff00';
                                for (let i = 0; i < 3; i++) {
                                    const angle = (this.animTimer * 0.1) + (i * Math.PI * 2 / 3);
                                    const starX = this.x + Math.cos(angle) * 30;
                                    const starY = baseY - 120 + Math.sin(angle) * 10;
                                    ctx.fillText('★', starX - 12, starY);
                                }
                            }
                            
                            // Reset filters before returning
                            ctx.filter = 'none';
                            ctx.globalAlpha = 1.0;
                            
                            ctx.restore();
                            return;
                        }
                    }
                }
                
                // Fall back to shape-based drawing
                // console.log(`[SPRITE FALLBACK] Character: ${this.characterName}, State: ${this.state}, Move: ${this.currentMove}, Grounded: ${this.grounded}, Crouching: ${this.crouching}`);
                
                if (this.state === 'knockdown' || this.knockdownFrames > 0) {
                    this.drawKnockdownSprite(baseY);
                } else if (this.state === 'beingThrown') {
                    this.drawBeingThrownSprite(baseY);
                } else if (this.state === 'throwingOpponent') {
                    this.drawThrowingSprite(baseY);
                } else if (this.currentMove === 'shoryuken') {
                    this.drawShoryukenSprite(baseY);
                } else if (this.currentMove === 'hadouken') {
                    this.drawHadoukenSprite(baseY);
                } else if (this.currentMove === 'tatsumaki') {
                    this.drawTatsumakiSprite(baseY);
                } else if (this.crouching) {
                    this.drawCrouchingSprite(baseY);
                } else if (!this.grounded) {
                    this.drawJumpingSprite(baseY);
                } else if (this.state === 'walk') {
                    this.drawWalkingSprite(baseY);
                } else if (this.state === 'attack') {
                    this.drawAttackSprite(baseY);
                } else {
                    this.drawIdleSprite(baseY);
                }
                
                // Dizzy stars
                if (this.isDizzy && !isAfterImage) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 24px Arial';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffff00';
                    for (let i = 0; i < 3; i++) {
                        const angle = (this.animTimer * 0.1) + (i * Math.PI * 2 / 3);
                        const starX = this.x + Math.cos(angle) * 30;
                        const starY = baseY - 120 + Math.sin(angle) * 10;
                        ctx.fillText('★', starX - 12, starY);
                    }
                }
                
                // Reset any filters before restoring
                ctx.filter = 'none';
                ctx.globalAlpha = 1.0;
                
                ctx.restore();
            }

            drawIdleSprite(baseY) {
                const bounce = Math.sin(this.animTimer * 0.1) * 2;
                
                // Debug: Show block direction indicator
                if (this.isPlayer) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.font = '12px Arial';
                    const blockDir = this.facing === 1 ? '← A' : '→ D';
                    ctx.fillText(`Block: ${blockDir}`, this.x - 20, baseY - 120);
                    ctx.restore();
                }
                
                // Head
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(this.x, baseY - 85 + bounce, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Hair
                ctx.fillStyle = this.hairColor;
                ctx.fillRect(this.x - 15, baseY - 100 + bounce, 30, 15);
                ctx.fillRect(this.x - 12, baseY - 102 + bounce, 24, 5);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - 8, baseY - 88 + bounce, 4, 4);
                ctx.fillRect(this.x + 4, baseY - 88 + bounce, 4, 4);
                
                // Body
                ctx.fillStyle = this.giColor;
                ctx.beginPath();
                ctx.moveTo(this.x - 20, baseY - 70 + bounce);
                ctx.lineTo(this.x + 20, baseY - 70 + bounce);
                ctx.lineTo(this.x + 25, baseY - 30 + bounce);
                ctx.lineTo(this.x - 25, baseY - 30 + bounce);
                ctx.closePath();
                ctx.fill();
                
                // Belt
                ctx.fillStyle = this.beltColor;
                ctx.fillRect(this.x - 25, baseY - 35 + bounce, 50, 8);
                
                // Pants
                ctx.fillStyle = this.pantsColor;
                ctx.beginPath();
                ctx.moveTo(this.x - 25, baseY - 27 + bounce);
                ctx.lineTo(this.x + 25, baseY - 27 + bounce);
                ctx.lineTo(this.x + 20, baseY);
                ctx.lineTo(this.x + 10, baseY);
                ctx.lineTo(this.x + 5, baseY - 15);
                ctx.lineTo(this.x - 5, baseY - 15);
                ctx.lineTo(this.x - 10, baseY);
                ctx.lineTo(this.x - 20, baseY);
                ctx.closePath();
                ctx.fill();
                
                // Arms
                ctx.fillStyle = this.skinColor;
                
                if (this.blocking && !this.crouching) {
                    // High blocking pose - crossed arms
                    ctx.save();
                    // Left arm across body
                    ctx.translate(this.x, baseY - 65 + bounce);
                    ctx.rotate(0.5);
                    ctx.fillRect(-5, 0, 35, 12);
                    ctx.fillRect(25, -2, 12, 16);
                    ctx.restore();
                    
                    // Right arm across body
                    ctx.save();
                    ctx.translate(this.x, baseY - 60 + bounce);
                    ctx.rotate(-0.3);
                    ctx.fillRect(-30, 0, 35, 12);
                    ctx.fillRect(-35, -2, 12, 16);
                    ctx.restore();
                    
                    // High blocking shield effect
                    ctx.save();
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.5 + Math.sin(this.animTimer * 0.2) * 0.2;
                    ctx.beginPath();
                    ctx.arc(this.x, baseY - 50 + bounce, 35, -0.5, Math.PI + 0.5);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    // Normal idle arms with swing
                    const armSwing = Math.sin(this.animTimer * 0.08) * 5;
                    // Left arm
                    ctx.save();
                    ctx.translate(this.x - 20, baseY - 65 + bounce);
                    ctx.rotate(armSwing * 0.02);
                    ctx.fillRect(-5, 0, 10, 30);
                    ctx.fillRect(-7, 28, 14, 14);
                    ctx.restore();
                    
                    // Right arm
                    ctx.save();
                    ctx.translate(this.x + 20, baseY - 65 + bounce);
                    ctx.rotate(-armSwing * 0.02);
                    ctx.fillRect(-5, 0, 10, 30);
                    ctx.fillRect(-7, 28, 14, 14);
                    ctx.restore();
                }
                
                // Feet
                ctx.fillRect(this.x - 20, baseY - 5, 15, 5);
                ctx.fillRect(this.x + 5, baseY - 5, 15, 5);
            }

            drawWalkingSprite(baseY) {
                const walkCycle = Math.floor(this.animFrame / 4) % 4;
                const legOffset = walkCycle * 10 - 15;
                
                // Similar to idle but with walking leg animation
                // Head and body same as idle
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(this.x, baseY - 85, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Hair
                ctx.fillStyle = this.hairColor;
                ctx.fillRect(this.x - 15, baseY - 100, 30, 15);
                
                // Body
                ctx.fillStyle = this.giColor;
                ctx.beginPath();
                ctx.moveTo(this.x - 20, baseY - 70);
                ctx.lineTo(this.x + 20, baseY - 70);
                ctx.lineTo(this.x + 25, baseY - 30);
                ctx.lineTo(this.x - 25, baseY - 30);
                ctx.closePath();
                ctx.fill();
                
                // Walking legs
                ctx.fillStyle = this.pantsColor;
                // Front leg
                ctx.save();
                ctx.translate(this.x + legOffset, baseY - 27);
                ctx.fillRect(-10, 0, 20, 27);
                ctx.restore();
                
                // Back leg
                ctx.save();
                ctx.translate(this.x - legOffset, baseY - 27);
                ctx.fillRect(-10, 0, 20, 25);
                ctx.restore();
                
                // Moving feet
                ctx.fillStyle = this.skinColor;
                ctx.fillRect(this.x + legOffset - 10, baseY - 5, 20, 5);
                ctx.fillRect(this.x - legOffset - 10, baseY - 3, 20, 3);
            }

            drawAttackSprite(baseY) {
                // Base body
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(this.x, baseY - 85, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Hair
                ctx.fillStyle = this.hairColor;
                ctx.fillRect(this.x - 15, baseY - 100, 30, 15);
                
                // Body
                ctx.fillStyle = this.giColor;
                ctx.beginPath();
                ctx.moveTo(this.x - 20, baseY - 70);
                ctx.lineTo(this.x + 20, baseY - 70);
                ctx.lineTo(this.x + 25, baseY - 30);
                ctx.lineTo(this.x - 25, baseY - 30);
                ctx.closePath();
                ctx.fill();
                
                // Attack specific poses
                if (this.currentMove && (this.currentMove === 'P' || this.currentMove === 'crP')) {
                    // Punch extension
                    const extension = 45;
                    ctx.fillStyle = this.skinColor;
                    ctx.save();
                    ctx.translate(this.x + 20, baseY - 65);
                    ctx.rotate(-0.2);
                    ctx.fillRect(0, -5, extension, 15);
                    // Fist
                    ctx.beginPath();
                    ctx.arc(extension, 5, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Motion lines
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + 20 + extension, baseY - 65 + i * 5);
                        ctx.lineTo(this.x + 20 + extension + 20, baseY - 65 + i * 5);
                        ctx.stroke();
                    }
                } else if (this.currentMove && (this.currentMove === 'K' || this.currentMove === 'crK')) {
                    // Kick extension
                    const extension = 60;
                    ctx.fillStyle = this.pantsColor;
                    ctx.save();
                    ctx.translate(this.x, baseY - 40);
                    ctx.rotate(-0.5);
                    ctx.fillRect(0, -10, extension, 20);
                    ctx.fillStyle = this.skinColor;
                    ctx.fillRect(extension, -8, 20, 16);
                    ctx.restore();
                }
                
                // Legs
                ctx.fillStyle = this.pantsColor;
                ctx.fillRect(this.x - 25, baseY - 30, 20, 30);
                if (!this.currentMove || !this.currentMove.includes('K')) {
                    ctx.fillRect(this.x + 5, baseY - 30, 20, 30);
                }
            }

            drawJumpingSprite(baseY) {
                // Rotating body for dynamic jump
                const rotation = this.velocityY * 0.02;
                
                ctx.save();
                ctx.translate(this.x, baseY - 50);
                ctx.rotate(rotation);
                
                // Head
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(0, -35, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Body
                ctx.fillStyle = this.giColor;
                ctx.fillRect(-25, -20, 50, 40);
                
                // Jumping attack pose
                if (this.currentMove && this.currentMove === 'jK') {
                    // Extended kick
                    ctx.fillStyle = this.pantsColor;
                    ctx.save();
                    ctx.rotate(0.8);
                    ctx.fillRect(0, 0, 70, 20);
                    ctx.fillStyle = this.skinColor;
                    ctx.fillRect(70, 2, 20, 16);
                    ctx.restore();
                } else if (this.currentMove && this.currentMove === 'jP') {
                    // Jumping punch
                    ctx.fillStyle = this.skinColor;
                    ctx.save();
                    ctx.rotate(-0.3);
                    const reach = 45;
                    ctx.fillRect(20, -10, reach, 15);
                    ctx.beginPath();
                    ctx.arc(20 + reach, -3, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Legs during punch
                    ctx.fillStyle = this.pantsColor;
                    ctx.fillRect(-20, 15, 15, 20);
                    ctx.fillRect(5, 15, 15, 20);
                } else {
                    // Tucked legs
                    ctx.fillStyle = this.pantsColor;
                    ctx.fillRect(-20, 15, 15, 20);
                    ctx.fillRect(5, 15, 15, 20);
                    
                    // Air blocking pose
                    if (this.blocking) {
                        ctx.fillStyle = this.skinColor;
                        // Arms in defensive position
                        ctx.fillRect(-30, -15, 15, 30);
                        ctx.fillRect(15, -15, 15, 30);
                    }
                }
                
                ctx.restore();
                
                // Air blocking shield effect
                if (this.blocking) {
                    ctx.save();
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.5 + Math.sin(this.animTimer * 0.2) * 0.2;
                    ctx.beginPath();
                    ctx.arc(this.x, baseY - 50, 45, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            drawCrouchingSprite(baseY) {
                // Compressed crouch position
                const squashY = baseY + 20;
                
                // Head lower
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(this.x, squashY - 55, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Compressed body
                ctx.fillStyle = this.giColor;
                ctx.fillRect(this.x - 25, squashY - 40, 50, 25);
                
                // Belt
                ctx.fillStyle = this.beltColor;
                ctx.fillRect(this.x - 25, squashY - 18, 50, 6);
                
                // Bent legs
                ctx.fillStyle = this.pantsColor;
                ctx.beginPath();
                ctx.moveTo(this.x - 25, squashY - 12);
                ctx.lineTo(this.x - 35, squashY);
                ctx.lineTo(this.x - 15, squashY);
                ctx.lineTo(this.x - 10, squashY - 12);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.x + 25, squashY - 12);
                ctx.lineTo(this.x + 35, squashY);
                ctx.lineTo(this.x + 15, squashY);
                ctx.lineTo(this.x + 10, squashY - 12);
                ctx.closePath();
                ctx.fill();
                
                // Low blocking pose
                if (this.blocking) {
                    ctx.fillStyle = this.skinColor;
                    // Arms in front for low block
                    ctx.save();
                    ctx.translate(this.x, squashY - 35);
                    ctx.rotate(0.3);
                    ctx.fillRect(-20, 0, 40, 12);
                    ctx.fillRect(-25, -2, 12, 16);
                    ctx.fillRect(15, -2, 12, 16);
                    ctx.restore();
                    
                    // Low blocking shield effect
                    ctx.save();
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.5 + Math.sin(this.animTimer * 0.2) * 0.2;
                    ctx.strokeRect(this.x - 30, squashY - 45, 60, 45);
                    ctx.restore();
                }
                
                // Crouch attacks
                if (this.state === 'attack' && this.currentMove) {
                    ctx.fillStyle = this.skinColor;
                    if (this.currentMove.includes('P')) {
                        // Low punch
                        ctx.fillRect(this.x + 25, squashY - 30, 40, 12);
                        ctx.beginPath();
                        ctx.arc(this.x + 65, squashY - 24, 8, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (this.currentMove.includes('K')) {
                        // Sweep
                        ctx.fillStyle = this.pantsColor;
                        ctx.save();
                        ctx.translate(this.x + 25, squashY - 10);
                        ctx.rotate(0.2);
                        ctx.fillRect(0, -8, 60, 16);
                        ctx.fillStyle = this.skinColor;
                        ctx.fillRect(60, -6, 18, 12);
                        ctx.restore();
                    }
                }
            }

            drawShoryukenSprite(baseY) {
                // Rising uppercut with rotation
                const rotation = this.moveFrame * 0.3;
                
                ctx.save();
                ctx.translate(this.x, baseY - 50);
                ctx.rotate(rotation);
                
                // Head tilted back
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(-5, -35, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Body
                ctx.fillStyle = this.giColor;
                ctx.fillRect(-20, -20, 40, 40);
                
                // Extended uppercut arm
                ctx.fillStyle = this.skinColor;
                ctx.save();
                ctx.rotate(-0.7);
                ctx.fillRect(-5, -60, 15, 60);
                ctx.beginPath();
                ctx.arc(2, -65, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Fire effect
                if (this.moveFrame < 20) {
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff6600';
                    ctx.fillStyle = 'rgba(255, 102, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, -40, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Create fire particles
                if (this.moveFrame % 2 === 0 && this.moveFrame < 20) {
                    for (let i = 0; i < 3; i++) {
                        particles.push(new Particle(
                            this.x + (Math.random() - 0.5) * 40,
                            baseY - 50 + (Math.random() - 0.5) * 40,
                            'fire'
                        ));
                    }
                }
            }

            drawHadoukenSprite(baseY) {
                // Kamehameha-style pose
                const chargePhase = this.moveFrame < 15;
                
                // Head
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(this.x - 10, baseY - 85, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Body leaning forward
                ctx.fillStyle = this.giColor;
                ctx.save();
                ctx.translate(this.x, baseY - 50);
                ctx.rotate(0.1);
                ctx.fillRect(-25, -20, 50, 40);
                ctx.restore();
                
                // Both arms extended
                ctx.fillStyle = this.skinColor;
                if (chargePhase) {
                    // Charging pose
                    ctx.fillRect(this.x - 30, baseY - 60, 15, 40);
                    ctx.fillRect(this.x + 15, baseY - 60, 15, 40);
                    
                    // Energy gathering
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    const size = 10 + Math.sin(this.moveFrame * 0.5) * 5;
                    const gradient = ctx.createRadialGradient(this.x + 20, baseY - 50, 0, this.x + 20, baseY - 50, size);
                    gradient.addColorStop(0, '#00ffff');
                    gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x + 20, baseY - 50, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // Release pose
                    ctx.fillRect(this.x + 20, baseY - 62, 45, 15);
                    ctx.fillRect(this.x + 20, baseY - 52, 45, 15);
                    ctx.beginPath();
                    ctx.arc(this.x + 65, baseY - 55, 10, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Legs in stance
                ctx.fillStyle = this.pantsColor;
                ctx.fillRect(this.x - 30, baseY - 30, 25, 30);
                ctx.fillRect(this.x + 5, baseY - 30, 25, 30);
            }

            drawTatsumakiSprite(baseY) {
                // Spinning kick with multiple frames
                const spin = this.moveFrame * 0.5;
                
                ctx.save();
                ctx.translate(this.x, baseY - 50);
                ctx.rotate(spin);
                
                // Spinning body
                ctx.fillStyle = this.giColor;
                ctx.fillRect(-20, -20, 40, 40);
                
                // Head
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(0, -35, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Extended leg
                ctx.fillStyle = this.pantsColor;
                ctx.fillRect(20, -5, 50, 20);
                ctx.fillStyle = this.skinColor;
                ctx.fillRect(70, -3, 20, 16);
                
                // Motion blur effect
                ctx.globalAlpha = 0.3;
                ctx.rotate(-0.5);
                ctx.fillStyle = this.pantsColor;
                ctx.fillRect(20, -5, 50, 20);
                ctx.rotate(-0.5);
                ctx.fillRect(20, -5, 50, 20);
                
                ctx.restore();
                
                // Wind particles
                if (this.moveFrame % 3 === 0) {
                    particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 60,
                        baseY - 50,
                        'dust'
                    ));
                }
            }

            drawKnockdownSprite(baseY) {
                // Horizontal knocked down position
                ctx.save();
                
                // Ensure no rotation during knockdown
                this.rotation = 0;
                
                ctx.translate(this.x, GROUND_Y);
                
                // Flatten on ground
                ctx.scale(1, 0.3);
                
                // Body
                ctx.fillStyle = this.giColor;
                ctx.fillRect(-40, -20, 80, 20);
                
                // Head
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(-45, -10, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            drawBeingThrownSprite(baseY) {
                // Victim being spun around - simplified sprite
                // Head
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y - 80, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Body (stretched/distorted)
                ctx.fillStyle = this.giColor;
                ctx.save();
                ctx.translate(this.x, this.y - 50);
                ctx.scale(0.8, 1.2);
                ctx.fillRect(-20, -20, 40, 40);
                ctx.restore();
                
                // Limbs flailing
                ctx.fillStyle = this.skinColor;
                const flail = Math.sin(this.throwAnimationFrame * 0.5) * 20;
                // Arms
                ctx.fillRect(this.x - 35 + flail, this.y - 60, 15, 30);
                ctx.fillRect(this.x + 20 - flail, this.y - 60, 15, 30);
                // Legs
                ctx.fillStyle = this.pantsColor;
                ctx.fillRect(this.x - 20 + flail * 0.5, this.y - 30, 15, 30);
                ctx.fillRect(this.x + 5 - flail * 0.5, this.y - 30, 15, 30);
                
                // Motion blur effect
                ctx.globalAlpha = 0.3;
                ctx.save();
                ctx.translate(this.x, this.y - 50);
                ctx.rotate(-this.rotation * 0.5);
                ctx.fillStyle = this.giColor;
                ctx.fillRect(-25, -25, 50, 50);
                ctx.restore();
                ctx.globalAlpha = 1;
            }
            
            drawThrowingSprite(baseY) {
                const progress = this.throwAnimationFrame / 30;
                
                // Head
                ctx.fillStyle = this.skinColor;
                ctx.beginPath();
                ctx.arc(this.x - 5, baseY - 85, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Body (leaning into throw)
                ctx.fillStyle = this.giColor;
                ctx.save();
                ctx.translate(this.x, baseY - 50);
                ctx.rotate(0.3 * (1 - progress)); // Lean forward then straighten
                ctx.fillRect(-25, -20, 50, 40);
                ctx.restore();
                
                // Throwing arm (gripping opponent)
                ctx.fillStyle = this.skinColor;
                const armAngle = -0.5 + progress * 1.5; // Swing over head
                ctx.save();
                ctx.translate(this.x + 10, baseY - 60);
                ctx.rotate(armAngle);
                ctx.fillRect(0, 0, 50, 20);
                // Hand gripping
                ctx.beginPath();
                ctx.arc(50, 10, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Other arm for balance
                ctx.save();
                ctx.translate(this.x - 10, baseY - 60);
                ctx.rotate(0.7);
                ctx.fillRect(-15, 0, 15, 40);
                ctx.restore();
                
                // Legs in power stance
                ctx.fillStyle = this.pantsColor;
                // Back leg
                ctx.fillRect(this.x - 25, baseY - 30, 20, 30);
                // Front leg
                ctx.save();
                ctx.translate(this.x + 5, baseY - 30);
                ctx.rotate(-0.2);
                ctx.fillRect(0, 0, 20, 35);
                ctx.restore();
                
                // Power lines for effect
                if (this.throwAnimationFrame < 15) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < 3; i++) {
                        const angle = i * 0.5 - 0.5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, baseY - 50);
                        ctx.lineTo(this.x + Math.cos(angle) * 40, baseY - 50 + Math.sin(angle) * 20);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
            }

            updateDrawing() {
                // Update animation
                this.animTimer++;
                if (this.animTimer % 4 === 0) {
                    this.animFrame++;
                }
                
                // Create motion trail for special moves
                if (this.currentMove === 'tatsumaki' || 
                    this.currentMove === 'shoryuken' ||
                    (this.state === 'attack' && this.currentMove && this.currentMove.includes('H'))) {
                    if (this.moveFrame % 2 === 0) {
                        afterImages.push(new AfterImage(this.x, this.y, this));
                    }
                }
                
                // Landing dust
                if (this.grounded && this.velocityY > 10) {
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(
                            this.x + (Math.random() - 0.5) * 40,
                            GROUND_Y,
                            'dust'
                        ));
                    }
                }
            }

            handleInput(keys) {
                // Don't process input during certain states
                if (this.state === 'hitstun' || this.state === 'knockdown' || 
                    this.knockdownFrames > 0 || this.state === 'throwingOpponent' || 
                    this.state === 'beingThrown') {
                    return;
                }
                
                // Update directional inputs for special moves
                // Skip if gamepad is active (gamepad handles its own directional inputs)
                const gamepadActive = navigator.getGamepads && 
                    Array.from(navigator.getGamepads()).some(gp => gp && gp.connected);
                
                if (!gamepadActive) {
                    const dirs = [];
                    if (keys['s']) dirs.push('2');
                    if (keys['w']) dirs.push('8');
                    if (this.facing === 1) {
                        if (keys['a']) dirs.push('4');
                        if (keys['d']) dirs.push('6');
                    } else {
                        if (keys['a']) dirs.push('6');
                        if (keys['d']) dirs.push('4');
                    }
                    
                    if (dirs.length === 0) dirs.push('5'); // Neutral
                    
                    // Add to input buffer
                    dirs.forEach(dir => {
                        if (!this.inputBuffer.directions.length || 
                            this.inputBuffer.directions[this.inputBuffer.directions.length - 1].dir !== dir) {
                            this.inputBuffer.addDirection(dir);
                        }
                    });
                }
                
                // Can't act during hitstun/blockstun (but still update facing for proper blocking direction)
                const inStun = this.hitstunFrames > 0 || this.blockstunFrames > 0 || this.knockdownFrames > 0;
                
                if (this.isPlayer && inStun) {
                    console.log('[PLAYER] In stun state:', {
                        hitstun: this.hitstunFrames,
                        blockstun: this.blockstunFrames,
                        knockdown: this.knockdownFrames
                    });
                }
                
                // Update facing FIRST (for cross-ups)
                const opponent = this.isPlayer ? aiPlayer : player;
                if (opponent && !this.knockdownFrames && this.state !== 'beingThrown' && this.state !== 'throwingOpponent') {
                    const oldFacing = this.facing;
                    this.facing = this.x < opponent.x ? 1 : -1;
                    
                    // If facing changed (cross-up), immediately update blocking
                    if (oldFacing !== this.facing) {
                        this.blocking = false; // Reset blocking on cross-up
                        console.log(`[${this.isPlayer ? 'PLAYER' : 'AI'}] Facing changed from ${oldFacing} to ${this.facing}`);
                    }
                }
                
                // Check blocking state BEFORE any attacks
                const backKey = this.facing === 1 ? 'a' : 'd';
                const holdingBack = keys[backKey];
                const holdingDown = keys['s'];
                
                // Check if opponent has active hitboxes
                let opponentHasActiveHitbox = opponent.hitboxes.length > 0;
                
                // Check for incoming projectiles
                const hasIncomingProjectile = opponent.projectiles.some(proj => {
                    // For money throw, check individual bills
                    if (proj.isMoneyThrow && proj.moneyBills) {
                        return proj.moneyBills.some(bill => {
                            if (bill.life <= 0) return false;
                            const billDistance = Math.abs(bill.x - this.x);
                            const billComingToward = (bill.facing === 1 && bill.x < this.x) || 
                                                   (bill.facing === -1 && bill.x > this.x);
                            return billComingToward && billDistance < 400; // Increased range for bills
                        });
                    }
                    
                    // Regular projectiles
                    const projDistance = Math.abs(proj.x - this.x);
                    const projComingToward = (proj.facing === 1 && proj.x < this.x) || 
                                           (proj.facing === -1 && proj.x > this.x);
                    return projComingToward && projDistance < 300;
                });
                
                // In Street Fighter, blocking vs walking backwards depends on proximity and threats
                const distance = Math.abs(this.x - opponent.x);
                const inBlockRange = distance < 150; // Close enough that back = block
                
                // Check if there's an active threat
                const hasActiveThreat = (opponentHasActiveHitbox && distance < 200) || hasIncomingProjectile;
                
                // You're in blocking stance if:
                // 1. Holding back AND there's an active threat (including projectiles)
                // 2. Holding back AND opponent is in attack state within block range
                // 3. Holding back AND very close to opponent
                const veryClose = distance < 80;
                const mediumRange = distance < 200;
                
                // More lenient blocking - if holding back and any threat exists
                this.blocking = holdingBack && !this.isDizzy && 
                    (hasActiveThreat || 
                     hasIncomingProjectile || 
                     (mediumRange && opponent.state === 'attack') ||
                     veryClose);
                
                // Debug logging for player - log every frame to catch the stuck state
                if (this.isPlayer) {
                    const debugInfo = {
                        blocking: this.blocking,
                        holdingBack: holdingBack,
                        backKey: backKey,
                        keys_a: keys['a'],
                        keys_d: keys['d'],
                        facing: this.facing,
                        inBlockRange: inBlockRange,
                        distance: distance,
                        hasActiveThreat: hasActiveThreat,
                        opponentHasActiveHitbox: opponentHasActiveHitbox,
                        hasIncomingProjectile: hasIncomingProjectile,
                        state: this.state,
                        hitstun: this.hitstunFrames,
                        blockstun: this.blockstunFrames,
                        isDizzy: this.isDizzy
                    };
                    
                    // Only log when something interesting is happening
                    if (holdingBack || this.blocking || this.state === 'walk' || this.blockstunFrames > 0) {
                        console.log('[PLAYER] Frame state:', JSON.stringify(debugInfo));
                    }
                }
                
                // Visual feedback for blocking type
                if (this.blocking) {
                    this.blockType = holdingDown ? 'low' : 'high';
                } else {
                    this.blockType = null;
                }
                
                // If in stun state, can't do anything else
                if (inStun) {
                    return;
                }
                
                // If blocking, don't allow attacks
                if (this.blocking) {
                    // Still allow movement while blocking
                    if (this.state !== 'attack') {
                        if (keys['s']) {
                            this.crouch();
                        } else {
                            this.crouching = false;
                        }
                    }
                    return;
                }
                
                // Check for throw (punch + kick)
                const punchPressed = keys['u'];  // Punch
                const kickPressed = keys['j'];   // Kick
                
                // Also check if punch or kick was pressed very recently (within 3 frames)
                const recentPunch = this.inputBuffer.buttons.some(b => 
                    b.btn === 'P' && b.time < 3
                );
                const recentKick = this.inputBuffer.buttons.some(b => 
                    b.btn === 'K' && b.time < 3
                );
                
                // Check if throw buttons are being pressed
                const throwButtonsCurrentlyPressed = (punchPressed && kickPressed) || (punchPressed && recentKick) || (kickPressed && recentPunch);
                
                // Debug throw button state
                if (this.isPlayer && (throwButtonsCurrentlyPressed || this.throwButtonsPressed)) {
                    console.log('[THROW] Button state:', {
                        currentlyPressed: throwButtonsCurrentlyPressed,
                        previouslyPressed: this.throwButtonsPressed,
                        canAttempt: throwButtonsCurrentlyPressed && !this.throwButtonsPressed
                    });
                }
                
                // Throw if both buttons pressed together OR within a small window
                // BUT require button release between throw attempts
                if (throwButtonsCurrentlyPressed && !this.throwButtonsPressed) {
                    // Check if we can throw
                    if (this.state !== 'attack' && this.state !== 'throwingOpponent' && 
                        this.state !== 'beingThrown' && this.grounded && this.throwCooldown <= 0) {
                        if (this.isPlayer) {
                            console.log('[THROW] Attempting throw with punch+kick!');
                        }
                        this.attemptThrow();
                        this.throwButtonsPressed = true;  // Mark buttons as pressed
                        return;
                    } else if (this.state === 'attack' && this.currentMove === 'throw') {
                        // Already throwing, don't process other attacks
                        this.throwButtonsPressed = true;  // Keep marking as pressed
                    } else if (this.state === 'throwingOpponent') {
                        // Already in throw animation, ignore inputs
                        this.throwButtonsPressed = true;  // Keep marking as pressed
                        return;
                    }
                } else if (!throwButtonsCurrentlyPressed) {
                    // Buttons released - allow next throw attempt
                    this.throwButtonsPressed = false;
                }
                
                // Check for special moves first
                if (this.state !== 'attack' || (this.currentMove && FRAME_DATA[this.currentMove].cancelable)) {
                    // Debug: log when buttons are pressed
                    const punch = keys['u'];  // Punch
                    const kick = keys['j'];   // Kick
                    
                    if (this.isPlayer && (punch || kick)) {
                        console.log('[SPECIAL] Button pressed! Punch:', punch, 'Kick:', kick);
                        console.log('[SPECIAL] Current buffer:', this.inputBuffer.directions.slice(-8).map(d => d.dir).join(''));
                    }
                    
                    // Check Hadouken first (Quarter Circle Forward)
                    // This prevents false Shoryuken detection when doing back->hadouken
                    if (this.inputBuffer.checkMotion('236') && punch) {
                        console.log('[SPECIAL] HADOUKEN TRIGGERED!');
                        this.performSpecialMove('hadouken');
                        return;
                    }
                    
                    // Shoryuken (Dragon Punch motion)
                    // More strict - requires forward->down->down-forward without back input
                    if (this.inputBuffer.checkMotion('623') && punch) {
                        console.log('[SPECIAL] SHORYUKEN TRIGGERED!');
                        this.performSpecialMove('shoryuken');
                        return;
                    }
                    
                    // Tatsumaki (Quarter Circle Back)
                    if (this.inputBuffer.checkMotion('214') && kick) {
                        console.log('[SPECIAL] TATSUMAKI TRIGGERED!');
                        this.performSpecialMove('tatsumaki');
                        return;
                    }
                }
                
                
                // Movement
                if (this.state !== 'attack') {
                    // Walking - allow backward movement when blocking if no active threat
                    const canWalkWhileBlocking = this.blocking && !hasActiveThreat && holdingBack;
                    
                    if (!this.blocking || canWalkWhileBlocking) {
                        if (keys['a'] && !this.crouching) {
                            // Only allow backward walk when blocking (walking away from opponent)
                            if (!this.blocking || (this.blocking && this.facing === 1)) {
                                this.walk(-1); // Always move left with A
                            }
                        } else if (keys['d'] && !this.crouching) {
                            // Only allow backward walk when blocking (walking away from opponent)
                            if (!this.blocking || (this.blocking && this.facing === -1)) {
                                this.walk(1);  // Always move right with D
                            }
                        } else if (this.grounded && Math.abs(this.velocityX) < 0.5) {
                            this.state = this.crouching ? 'crouch' : 'idle';
                        }
                    } else {
                        // When blocking with active threat, set appropriate state but don't walk
                        if (this.grounded && Math.abs(this.velocityX) < 0.5) {
                            this.state = this.crouching ? 'crouch' : 'idle';
                        }
                    }
                    
                    // Crouching (only update if not blocking)
                    if (!this.blocking) {
                        if (keys['s']) {
                            this.crouch();
                        } else {
                            this.crouching = false;
                        }
                    }
                    
                    // Jumping - SF2 style with directional jumps
                    if (keys['w'] && this.grounded && !this.crouching) {
                        if (keys['a']) {
                            this.jump(-1); // Jump backward (left)
                        } else if (keys['d']) {
                            this.jump(1);  // Jump forward (right)
                        } else {
                            this.jump(0);  // Neutral jump
                        }
                    }
                }
                
                // Normal attacks - Simplified 2 BUTTON SYSTEM (respect throw cooldown)
                if ((this.state !== 'attack' || this.canCancelIntoNormal()) && this.throwCooldown <= 0) {
                    if (!this.grounded) {
                        // Jumping attacks
                        if (keys['u']) this.attack('jP');
                        else if (keys['j']) this.attack('jK');
                    } else if (this.crouching) {
                        // Crouching attacks
                        if (keys['u']) this.attack('crP');
                        else if (keys['j']) this.attack('crK');
                    } else {
                        // Standing attacks
                        if (keys['u']) this.attack('P');
                        else if (keys['j']) this.attack('K');
                    }
                }
            }

            walk(direction) {
                // Blocking check is now handled in handleInput movement section
                
                if (this.grounded && !this.crouching) {
                    const speed = direction === this.facing ? WALK_SPEED_FORWARD : WALK_SPEED_BACKWARD;
                    this.velocityX = direction * speed;
                    this.state = 'walk';
                    
                    if (this.isPlayer) {
                        console.log('[PLAYER] Walking', JSON.stringify({
                            direction: direction,
                            facing: this.facing,
                            walkingBackward: direction !== this.facing
                        }));
                    }
                }
            }

            crouch() {
                if (this.grounded) {
                    this.crouching = true;
                    this.state = 'crouch';
                    this.velocityX = 0;
                }
            }

            jump(direction) {
                // Can only jump if grounded
                if (!this.grounded) {
                    console.log(`[${this.isPlayer ? 'PLAYER' : 'AI'}] Attempted to jump while airborne!`);
                    return;
                }
                
                this.velocityY = JUMP_VELOCITY_Y;
                this.jumpDirection = direction;
                this.velocityX = direction * JUMP_VELOCITY_X;
                this.grounded = false;
                this.state = 'jump';
            }

            attack(button) {
                // Cancel rules
                if (this.state === 'attack' && this.currentMove) {
                    const currentData = FRAME_DATA[this.currentMove];
                    if (!currentData.cancelable || this.moveFrame < currentData.startup + currentData.active) {
                        return; // Can't cancel yet
                    }
                }
                
                this.state = 'attack';
                this.currentMove = button;
                this.moveFrame = 0;
                this.currentMoveHits = 0;  // Reset hit counter
                this.lastHitFrame = -999;  // Reset last hit frame
                this.blocking = false;  // Clear blocking when attacking
                this.inputBuffer.addButton(button);
                
                // Increment punch counter for variety
                if (button === 'P') {
                    this.punchCount++;
                }
            }

            performSpecialMove(move) {
                if (this.state === 'attack' && this.currentMove) {
                    const currentData = FRAME_DATA[this.currentMove];
                    if (!currentData.cancelable) return;
                }
                
                this.state = 'attack';
                this.currentMove = move;
                this.moveFrame = 0;
                this.currentMoveHits = 0;  // Reset hit counter
                this.lastHitFrame = -999;  // Reset last hit frame
                this.blocking = false;  // Clear blocking when attacking
                
                // Special properties
                if (move === 'shoryuken') {
                    this.invincibleFrames = FRAME_DATA[move].invincible;
                    this.velocityY = -10;
                    this.grounded = false;
                } else if (move === 'tatsumaki') {
                    this.velocityX = this.facing * 4;
                    if (!this.grounded) this.velocityY = -2;
                } else if (move === 'hadouken' && this.grounded) {
                    // Will spawn projectile during active frames
                }
                
                // Clear input buffer
                this.inputBuffer.clear();
            }

            attemptThrow() {
                // Don't attempt if already throwing
                if (this.state === 'throwingOpponent' || this.state === 'beingThrown') {
                    return;
                }
                
                const opponent = this.isPlayer ? aiPlayer : player;
                const distance = Math.abs(this.x - opponent.x);
                
                // Always start throw animation
                this.state = 'attack';
                this.currentMove = 'throw';
                this.moveFrame = 0;
                this.currentMoveHits = 0;  // Reset hit counter - CRITICAL for collision detection
                this.lastHitFrame = -999;  // Reset last hit frame
                this.blocking = false;  // Clear blocking when attacking
                this.isThrowAttempt = true;
                this.throwCooldown = 60; // Longer cooldown to prevent spam
                
                // Step forward slightly during throw startup (first 3 frames)
                const stepForward = distance > 60 && distance < THROW_RANGE;
                if (stepForward) {
                    // Move toward opponent during startup
                    const direction = opponent.x > this.x ? 1 : -1;
                    this.velocityX = direction * 2; // Small step forward
                }
                
                // Don't set tech window here - let collision detection handle it
            }

            canCancelIntoNormal() {
                // Link timing for combos
                if (this.state === 'idle' && this.moveFrame < 3) {
                    return true;
                }
                return false;
            }

            updateHitboxes() {
                this.hurtboxes = [];
                this.hitboxes = [];
                
                // Invincibility check
                if (this.invincibleFrames > 0) {
                    return; // No hurtboxes during invincibility
                }
                
                // Hurtboxes based on state - tightly encompass the character
                const spriteScale = 0.41;
                const spriteHeight = 728 * spriteScale; // ~298 pixels tall
                const characterHeight = spriteHeight * 0.9; // Character takes up 90% of sprite
                
                if (this.knockdownFrames > 0) {
                    // Lying down hitbox - close to ground
                    this.hurtboxes.push({ x: -100, y: -50, width: 200, height: 50 });
                } else if (this.crouching) {
                    // Crouching - about 50% of character height
                    const crouchHeight = characterHeight * 0.5;
                    this.hurtboxes.push({ x: -60, y: -crouchHeight, width: 120, height: crouchHeight });
                } else if (!this.grounded) {
                    // Jumping - full character height
                    this.hurtboxes.push({ x: -60, y: -characterHeight + 20, width: 120, height: characterHeight - 20 });
                } else {
                    // Standing hurtbox - from feet to head
                    this.hurtboxes.push({ x: -60, y: -characterHeight, width: 120, height: characterHeight });
                }
                
                // Attack hitboxes - don't generate during throwing animation
                if (this.state === 'attack' && this.currentMove && this.state !== 'throwingOpponent') {
                    const frameData = FRAME_DATA[this.currentMove];
                    if (frameData && this.moveFrame >= frameData.startup && 
                        this.moveFrame < frameData.startup + frameData.active) {
                        
                        if (this.currentMove === 'throw') {
                            // Check distance again during active frames
                            const opponent = this.isPlayer ? aiPlayer : player;
                            const distance = Math.abs(this.x - opponent.x);
                            
                            if (this.isPlayer) {
                                console.log('[THROW] Active frame check:', {
                                    frame: this.moveFrame,
                                    distance: distance,
                                    inRange: distance < THROW_RANGE,
                                    opponentGrounded: opponent.grounded
                                });
                            }
                            
                            // Only create throw hitbox if in range and opponent is throwable
                            if (distance < THROW_RANGE && opponent.grounded && !opponent.knockdownFrames) {
                                // Position throw hitbox based on opponent's position
                                const opponentDirection = opponent.x > this.x ? 1 : -1;
                                
                                if (this.isPlayer) {
                                    console.log('[THROW] Opponent direction:', {
                                        playerX: this.x,
                                        opponentX: opponent.x,
                                        opponentIsToTheRight: opponentDirection === 1
                                    });
                                }
                                
                                const throwHitbox = {
                                    x: opponentDirection === 1 ? 10 : -80,  // Hitbox toward opponent
                                    y: -80,
                                    width: 80,  // Wide hitbox
                                    height: 80,  // Tall hitbox
                                    type: 'throw'
                                };
                                
                                this.hitboxes.push(throwHitbox);
                                
                                if (this.isPlayer) {
                                    console.log('[THROW] Hitbox created!', {
                                        x: throwHitbox.x,
                                        y: throwHitbox.y,
                                        width: throwHitbox.width,
                                        height: throwHitbox.height,
                                        fighterX: this.x,
                                        opponentX: opponent.x
                                    });
                                }
                            }
                        } else if (this.currentMove.includes('P') || this.currentMove.includes('punch')) {
                            // Punch hitboxes
                            let reach = 50;
                            if (this.currentMove.includes('H')) reach = 70;
                            else if (this.currentMove.includes('M')) reach = 60;
                            
                            this.hitboxes.push({
                                x: this.facing === 1 ? 25 : -25 - reach,
                                y: this.currentMove.includes('cr') ? -50 : -100,  // Adjusted for larger sprites
                                width: reach,
                                height: 30
                            });
                        } else if (this.currentMove.includes('K') || this.currentMove === 'tatsumaki') {
                            // Kick hitboxes
                            let reach = 60;
                            if (this.currentMove.includes('H')) reach = 90;
                            else if (this.currentMove.includes('M')) reach = 75;
                            
                            this.hitboxes.push({
                                x: this.facing === 1 ? 25 : -25 - reach,
                                y: this.currentMove.includes('cr') ? -40 : this.currentMove.includes('j') ? -60 : -80,  // Adjusted for larger sprites
                                width: reach,
                                height: 35
                            });
                        } else if (this.currentMove === 'shoryuken') {
                            // Rising uppercut hitbox
                            this.hitboxes.push({
                                x: this.facing === 1 ? 10 : -40,
                                y: -120,  // Adjusted for larger sprites
                                width: 35,
                                height: 100
                            });
                        }
                    }
                }
            }

            update() {
                // Update input buffer
                this.inputBuffer.update();
                
                // Update invincibility
                if (this.invincibleFrames > 0) this.invincibleFrames--;
                
                // Clean up stuck beingThrown state (but not during active throw)
                if (this.beingThrown && this.state !== 'beingThrown' && 
                    (!this.throwAttacker || this.throwAttacker.state !== 'throwingOpponent')) {
                    console.log('[THROW] Cleaning up stuck beingThrown state', {
                        beingThrown: this.beingThrown,
                        state: this.state,
                        throwAttacker: this.throwAttacker ? this.throwAttacker.state : 'null'
                    });
                    this.beingThrown = false;
                    this.throwAttacker = null;
                    this.throwAnimationFrame = 0;
                }
                
                // Decrement cooldowns
                if (this.throwCooldown > 0) this.throwCooldown--;
                
                // Handle being thrown animation
                if (this.state === 'beingThrown' && this.throwAttacker) {
                    this.throwAnimationFrame++;
                    
                    if (this.isPlayer) {
                        console.log('[THROW] Being thrown animation frame:', this.throwAnimationFrame);
                    }
                    
                    // Stick to attacker during throw
                    const throwDuration = 30;
                    if (this.throwAnimationFrame < throwDuration) {
                        // Determine throw direction based on available space
                        const distanceToLeftWall = this.throwAttacker.x;
                        const distanceToRightWall = canvas.width - this.throwAttacker.x;
                        const throwDirection = distanceToLeftWall > distanceToRightWall ? -1 : 1;
                        
                        // Position victim relative to attacker
                        const progress = this.throwAnimationFrame / throwDuration;
                        
                        // Graceful arc motion - like a judo throw
                        const liftHeight = Math.sin(progress * Math.PI) * 60;  // Moderate lift
                        const arcMotion = Math.sin(progress * Math.PI) * 20;  // Smooth arc
                        const offsetX = throwDirection * (30 + progress * 80);  // Reasonable distance
                        
                        this.x = this.throwAttacker.x + offsetX;
                        this.y = this.throwAttacker.y - 50 - liftHeight;
                        
                        // Store throw direction for launch
                        this.throwDirection = throwDirection;
                        
                        // Gentle rotation - just one flip
                        this.rotation = progress * Math.PI * 2;  // One graceful rotation
                    } else {
                        // Throw complete - launch the victim gracefully
                        console.log('[THROW] Launch phase!', {
                            victim: this.isPlayer ? 'PLAYER' : 'AI',
                            throwDirection: this.throwDirection,
                            velocityBefore: this.velocityX
                        });
                        
                        this.state = 'knockdown';
                        this.knockdownFrames = 50;  // Reasonable knockdown time
                        this.velocityY = -12;  // Clean arc
                        this.velocityX = (this.throwDirection || 1) * 50;  // Half screen distance
                        this.pushbackVelocity = 0;
                        this.rotation = 0;
                        this.beingThrown = false;
                        
                        console.log('[THROW] Launch velocities set!', {
                            velocityX: this.velocityX,
                            velocityY: this.velocityY,
                            state: this.state
                        });
                        
                        // Apply throw damage
                        this.takeDamage(12, 0, 0, 0, true, this.throwAttacker);
                        
                        // Create impact particles for dramatic effect
                        for (let i = 0; i < 8; i++) {
                            particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * 40,
                                this.y - 50,
                                'impact'
                            ));
                        }
                        
                        // Clear throw reference
                        this.throwAttacker = null;
                        
                        // Screen shake for impact
                        screenShake = 6;  // Moderate screen shake
                    }
                    return; // Skip normal physics
                }
                
                // Handle throwing animation
                if (this.state === 'throwingOpponent') {
                    this.throwAnimationFrame++;
                    
                    if (this.isPlayer) {
                        console.log('[THROW] Throwing animation frame:', this.throwAnimationFrame);
                    }
                    
                    if (this.throwAnimationFrame >= 30) {
                        // Animation complete
                        this.state = 'idle';
                        this.currentMove = null;
                        this.throwAnimationFrame = 0;
                        this.throwCooldown = 20; // Add cooldown after throw completes
                        
                        // Don't reset opponent here - let their beingThrown animation complete naturally
                    }
                    return; // Skip normal attack processing
                }
                
                // Update stun states - but not if being thrown
                if (this.state !== 'beingThrown' && this.state !== 'throwingOpponent') {
                    if (this.hitstunFrames > 0) {
                        this.hitstunFrames--;
                        this.state = 'hitstun';
                    } else if (this.blockstunFrames > 0) {
                        this.blockstunFrames--;
                        this.state = 'blockstun';
                    } else if (this.knockdownFrames > 0) {
                        this.knockdownFrames--;
                        this.state = 'knockdown';
                        if (this.knockdownFrames === 0) {
                            this.state = 'idle';
                            this.y = GROUND_Y;
                            this.rotation = 0;  // Reset rotation after knockdown
                        }
                    } else if (this.isDizzy) {
                        this.state = 'dizzy';
                        this.rotation = 0;  // Reset rotation
                    } else if (this.state === 'hitstun' || this.state === 'blockstun') {
                        // Reset to idle if we were in hitstun/blockstun but frames are 0
                        this.state = 'idle';
                        this.rotation = 0;  // Reset rotation
                    }
                }
                
                // Update dizzy state
                if (this.stunMeter > 0 && this.state !== 'hitstun') {
                    this.stunMeter -= 0.2;
                    if (this.stunMeter <= 0) {
                        this.isDizzy = false;
                    }
                }
                
                // Update attack state
                if (this.state === 'attack' && this.currentMove) {
                    this.moveFrame++;
                    const frameData = FRAME_DATA[this.currentMove];
                    
                    // Check if frameData exists (move might have been removed)
                    if (!frameData) {
                        console.error(`[FIGHTER] Invalid move: ${this.currentMove} not found in FRAME_DATA`);
                        this.endAttack();
                        return;
                    }
                    
                    // Spawn projectile for hadouken
                    if (this.currentMove === 'hadouken' && this.moveFrame === frameData.startup) {
                        let spawnX, spawnY;
                        
                        if (this.characterName === 'elon') {
                            // Flamethrower spawn position - from gun barrel
                            // Gun extends far forward at hip level
                            spawnX = this.x + (this.facing * 120);  // Gun barrel extends far forward
                            spawnY = this.y - 150;  // Adjusted 80 pixels higher total for correct barrel position
                        } else {
                            // Regular hadouken spawn position - from hands
                            spawnX = this.x + (this.facing * 45);
                            spawnY = this.y - 110;
                        }
                        
                        this.projectiles.push(new Projectile(
                            spawnX,
                            spawnY,
                            this.facing,
                            this,
                            frameData
                        ));
                    }
                    
                    // End move
                    if (frameData.hits && frameData.hits > 1) {
                        // Multi-hit moves like tatsumaki
                        if (this.moveFrame >= frameData.startup + frameData.active + frameData.recovery) {
                            this.endAttack();
                        }
                    } else if (this.moveFrame >= frameData.startup + frameData.active + frameData.recovery) {
                        // Debug log for hadouken
                        if (this.currentMove === 'hadouken') {
                            console.log('[HADOUKEN] Ending move at frame:', this.moveFrame);
                        }
                        this.endAttack();
                    }
                }
                
                // Physics
                if (!this.grounded) {
                    this.velocityY += GRAVITY;
                }
                
                // Track position for debugging teleport issues
                const oldX = this.x;
                const oldY = this.y;
                
                this.y += this.velocityY;
                this.x += this.velocityX + this.pushbackVelocity;
                
                // Debug large position changes
                if (this.isPlayer && (Math.abs(this.x - oldX) > 50 || Math.abs(this.y - oldY) > 50)) {
                    console.log('[PLAYER] Large position change detected!', {
                        oldPos: {x: oldX, y: oldY},
                        newPos: {x: this.x, y: this.y},
                        state: this.state,
                        move: this.currentMove,
                        velocities: {x: this.velocityX, y: this.velocityY, pushback: this.pushbackVelocity}
                    });
                }
                
                // Ground collision
                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.grounded = true;
                    this.velocityY = 0;
                    this.jumpDirection = 0;
                    
                    if (this.state === 'jump') {
                        this.state = 'idle';
                    }
                    
                    // Landing recovery for some moves
                    if (this.currentMove === 'shoryuken' || this.currentMove === 'tatsumaki') {
                        this.moveFrame = 100; // Force recovery
                    }
                } else {
                    this.grounded = false;
                }
                
                // Friction (but not during throw startup to allow stepping forward)
                if (this.grounded) {
                    // Don't apply friction during throw startup frames
                    if (!(this.currentMove === 'throw' && this.moveFrame < 3)) {
                        this.velocityX *= 0.85;
                    }
                }
                this.pushbackVelocity *= 0.9;
                
                // Bounds - smooth clamping to prevent teleporting
                const margin = 50;
                const oldBoundedX = this.x;
                if (this.x < margin) {
                    this.x = margin;
                    this.velocityX = Math.max(0, this.velocityX); // Stop leftward movement
                } else if (this.x > canvas.width - margin) {
                    this.x = canvas.width - margin;
                    this.velocityX = Math.min(0, this.velocityX); // Stop rightward movement
                }
                
                // Debug if bounds caused a large change
                if (this.isPlayer && Math.abs(this.x - oldBoundedX) > 30) {
                    console.log('[PLAYER] Bounds correction:', {from: oldBoundedX, to: this.x});
                }
                
                // Update facing for auto-face (for both player and AI)
                const opponent = this.isPlayer ? aiPlayer : player;
                if (opponent && !this.knockdownFrames && this.state !== 'beingThrown' && this.state !== 'throwingOpponent') {
                    const oldFacing = this.facing;
                    this.facing = this.x < opponent.x ? 1 : -1;
                    
                    // If facing changed (cross-up), log it
                    if (oldFacing !== this.facing) {
                        console.log(`[${this.isPlayer ? 'PLAYER' : 'AI'}] Facing changed from ${oldFacing} to ${this.facing}`);
                    }
                }
                
                // Update hitboxes
                this.updateHitboxes();
                
                // Update projectiles
                this.projectiles = this.projectiles.filter(p => {
                    p.update();
                    return p.active;
                });
                
                // Animation
                this.animTimer++;
                if (this.animTimer % 4 === 0) {
                    this.animFrame++;
                }
                
                // Create motion trail for special moves
                if (this.currentMove === 'tatsumaki' || 
                    this.currentMove === 'shoryuken' ||
                    (this.state === 'attack' && this.currentMove && this.currentMove.includes('H'))) {
                    if (this.moveFrame % 2 === 0) {
                        afterImages.push(new AfterImage(this.x, this.y, this));
                    }
                }
                
                // Landing dust
                if (this.grounded && this.velocityY > 10) {
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(
                            this.x + (Math.random() - 0.5) * 40,
                            GROUND_Y,
                            'dust'
                        ));
                    }
                }
            }

            endAttack() {
                // If we just finished a throw attempt, add a small cooldown
                if (this.currentMove === 'throw') {
                    this.throwCooldown = 10;  // Prevent immediate attacks after throw
                    
                    // Reset any stuck beingThrown state on the opponent
                    const opponent = this.isPlayer ? aiPlayer : player;
                    if (opponent.beingThrown && opponent.state !== 'beingThrown') {
                        console.log('[THROW] Resetting stuck beingThrown flag on opponent');
                        opponent.beingThrown = false;
                        opponent.throwAttacker = null;
                        opponent.throwAnimationFrame = 0;
                    }
                }
                
                // Debug log for special moves
                if (this.currentMove === 'hadouken' || this.currentMove === 'shoryuken' || this.currentMove === 'tatsumaki') {
                    console.log(`[FIGHTER] Ending special move: ${this.currentMove}`);
                }
                
                this.state = 'idle';
                this.currentMove = null;
                this.moveFrame = 0;
                this.isThrowAttempt = false;
            }

            takeDamage(damage, hitstun, blockstun, pushback, knockdown = false, attacker = null, projectile = false) {
                // Check blocking at the moment of impact
                const isLowAttack = FRAME_DATA[attacker?.currentMove]?.low;
                
                // Debug logging
                console.log(`[${this.isPlayer ? 'PLAYER' : 'CPU'}] Taking damage:`, {
                    attack: attacker?.currentMove,
                    damage: damage,
                    blocking: this.blocking,
                    crouching: this.crouching,
                    grounded: this.grounded,
                    isLowAttack: isLowAttack,
                    state: this.state,
                    hitstun: this.hitstunFrames,
                    blockstun: this.blockstunFrames
                });
                
                // Blocking logic:
                // - Crouch block blocks EVERYTHING
                // - Stand block blocks everything EXCEPT low attacks
                // - Air block blocks everything (if we allow it)
                let blocked = false;
                
                if (this.blocking) {
                    if (this.crouching) {
                        // Crouch block blocks ALL attacks
                        blocked = true;
                    } else if (this.grounded && !isLowAttack) {
                        // Stand block blocks mid/high attacks only
                        blocked = true;
                    } else if (!this.grounded) {
                        // Air block (allowing it for better gameplay)
                        blocked = true;
                    }
                }
                
                console.log(`[${this.isPlayer ? 'PLAYER' : 'CPU'}] Block result:`, blocked, 
                    blocked ? 'BLOCKED!' : `HIT! (isLow: ${isLowAttack}, crouching: ${this.crouching})`);
                
                // Failed to block low attack while standing
                if (this.blocking && this.grounded && !this.crouching && isLowAttack) {
                    // Visual indicator of failed block
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(
                            this.x + (Math.random() - 0.5) * 40,
                            this.y - 20,
                            'hit'
                        ));
                    }
                }
                
                
                if (blocked) {
                    // Successful block - chip damage (special moves do more chip)
                    let chipMultiplier = 0.05; // Default chip damage
                    
                    if (attacker?.currentMove?.includes('flamethrower')) {
                        chipMultiplier = 0.75; // Flamethrower does 75% damage even when blocked!
                    } else if (attacker?.currentMove === 'hadouken' && projectile) {
                        // Check if this is Trump's money throw by checking the damage value
                        if (damage <= 0.02) {
                            chipMultiplier = 0.01; // Money throw does almost no chip damage when blocked
                        } else {
                            chipMultiplier = 0.15; // Regular hadouken
                        }
                    } else if (attacker?.currentMove?.includes('shoryuken') || 
                               attacker?.currentMove?.includes('tatsumaki')) {
                        chipMultiplier = 0.15; // Regular special moves
                    }
                    const chipDamage = damage * chipMultiplier;
                    this.health -= chipDamage;
                    this.blockstunFrames = blockstun;
                    this.pushbackVelocity = -this.facing * pushback * 0.6;
                    
                    // Block effect removed
                    
                    // Show chip damage number
                    if (chipDamage > 0) {
                        particles.push({
                            x: this.x,
                            y: this.y - 100,
                            life: 30,
                            type: 'chip',
                            text: `-${chipDamage.toFixed(chipDamage < 1 ? 2 : 0)}`,
                            vy: -2,
                            update() {
                                this.y += this.vy;
                                this.vy += 0.1;
                                this.life--;
                            },
                            draw() {
                                ctx.save();
                                ctx.globalAlpha = this.life / 30;
                                ctx.font = 'bold 16px Arial';
                                ctx.fillStyle = '#ff9900';
                                ctx.strokeStyle = '#000';
                                ctx.lineWidth = 2;
                                ctx.strokeText(this.text, this.x, this.y);
                                ctx.fillText(this.text, this.x, this.y);
                                ctx.restore();
                            }
                        });
                    }
                    
                    // Block particles
                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(
                            this.x + this.facing * 30 + (Math.random() - 0.5) * 20,
                            this.y - 60 + (Math.random() - 0.5) * 20,
                            'block'
                        ));
                    }
                } else {
                    // Full damage
                    this.health -= damage;
                    this.stunMeter += damage * 0.5;
                    
                    if (this.stunMeter >= this.maxStun) {
                        this.isDizzy = true;
                        this.stunMeter = this.maxStun;
                    }
                    
                    if (knockdown) {
                        this.knockdownFrames = 60;
                        this.velocityY = -8;
                        this.pushbackVelocity = -this.facing * pushback * 1.5;
                    } else {
                        this.hitstunFrames = hitstun;
                        this.pushbackVelocity = -this.facing * pushback;
                    }
                    
                    // Hit particles
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(
                            this.x + this.facing * 20 + (Math.random() - 0.5) * 30,
                            this.y - 60 + (Math.random() - 0.5) * 30,
                            'hit'
                        ));
                    }
                    
                    // Hit spark effect - position at impact point
                    // Get the actual hit location from the attacker's move data
                    let sparkX = this.x + this.facing * 30;
                    let sparkY = this.y - 150; // Default to mid-body
                    
                    // If we have attacker info and move data with impact point
                    if (attacker && attacker.currentMove) {
                        const moveData = FRAME_DATA[attacker.currentMove];
                        if (moveData && moveData.impactPoint) {
                            // Use the predefined impact point, adjusted for facing
                            sparkX = attacker.x + (attacker.facing === 1 ? moveData.impactPoint.x : -moveData.impactPoint.x);
                            sparkY = attacker.y + moveData.impactPoint.y;
                        } else if (attacker.hitboxes.length > 0) {
                            // Fallback to hitbox center
                            const hitbox = attacker.hitboxes[0];
                            sparkX = attacker.x + hitbox.x + hitbox.width / 2;
                            sparkY = attacker.y + hitbox.y + hitbox.height / 2;
                        }
                    }
                    
                    particles.push({
                        x: sparkX,
                        y: sparkY,
                        life: 15,
                        type: 'hitSpark',
                        size: 40,
                        update() {
                            this.life--;
                            this.size += 5;
                        },
                        draw() {
                            ctx.save();
                            ctx.globalAlpha = this.life / 15;
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            // Draw star burst
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const x1 = this.x + Math.cos(angle) * this.size;
                                const y1 = this.y + Math.sin(angle) * this.size;
                                const x2 = this.x + Math.cos(angle) * (this.size * 0.5);
                                const y2 = this.y + Math.sin(angle) * (this.size * 0.5);
                                ctx.moveTo(x2, y2);
                                ctx.lineTo(x1, y1);
                            }
                            ctx.stroke();
                            ctx.restore();
                        }
                    });
                    
                    // Combo tracking
                    if (attacker && attacker.comboCount > 0) {
                        attacker.comboCount++;
                    } else if (attacker) {
                        attacker.comboCount = 1;
                    }
                    
                    // Screen effects
                    screenShake = knockdown ? 12 : 6;
                    hitPause = 4;
                }
                
                this.health = Math.max(0, this.health);
            }

            drawHealthBar(x, y) {
                // Background with gradient
                const bgGradient = ctx.createLinearGradient(x, y, x, y + 35);
                bgGradient.addColorStop(0, '#333');
                bgGradient.addColorStop(1, '#111');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(x, y, 350, 35);
                
                // Inner background
                ctx.fillStyle = '#1a0000';
                ctx.fillRect(x + 3, y + 3, 344, 29);
                
                // Health bar with gradient
                const healthWidth = (this.health / this.maxHealth) * 344;
                const healthGradient = ctx.createLinearGradient(x + 3, y + 3, x + 3, y + 32);
                healthGradient.addColorStop(0, '#ffff00');
                healthGradient.addColorStop(0.5, '#ffcc00');
                healthGradient.addColorStop(1, '#ff9900');
                ctx.fillStyle = healthGradient;
                ctx.fillRect(x + 3, y + 3, healthWidth, 29);
                
                // Damage preview (red part)
                if (this.health < this.maxHealth) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(x + 3 + healthWidth, y + 3, 344 - healthWidth, 29);
                }
                
                // Health segments
                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.lineWidth = 1;
                for (let i = 1; i < 10; i++) {
                    const segX = x + 3 + (344 / 10) * i;
                    ctx.beginPath();
                    ctx.moveTo(segX, y + 3);
                    ctx.lineTo(segX, y + 32);
                    ctx.stroke();
                }
                
                // Glossy effect
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.fillRect(x + 3, y + 3, 344, 14);
                
                // Border
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, 350, 35);
                
                // Name with glow
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.shadowColor = this.isPlayer ? '#00ff00' : '#ff0000';
                ctx.shadowBlur = 10;
                ctx.fillText(this.isPlayer ? 'ELON MUSK' : 'DONALD TRUMP', x + 5, y - 8);
                ctx.shadowBlur = 0;
                
                // Stun gauge
                if (this.stunMeter > 0) {
                    const stunWidth = (this.stunMeter / this.maxStun) * 120;
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
                    ctx.fillRect(x, y + 37, 120, 6);
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(x, y + 37, stunWidth, 6);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y + 37, 120, 6);
                }
                
                // Super meter with glow
                const superWidth = (this.superMeter / this.maxSuper) * 200;
                ctx.fillStyle = 'rgba(0, 150, 255, 0.3)';
                ctx.fillRect(x, y + 45, 200, 10);
                
                const superGradient = ctx.createLinearGradient(x, y + 45, x + superWidth, y + 45);
                superGradient.addColorStop(0, '#0066ff');
                superGradient.addColorStop(0.5, '#0099ff');
                superGradient.addColorStop(1, '#00ccff');
                ctx.fillStyle = superGradient;
                ctx.fillRect(x, y + 45, superWidth, 10);
                
                if (this.superMeter >= this.maxSuper) {
                    ctx.shadowColor = '#0099ff';
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y + 45, 200, 10);
                    ctx.shadowBlur = 0;
                    
                    // "SUPER READY" text
                    ctx.fillStyle = '#00ffff';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText('SUPER READY!', x + 205, y + 55);
                } else {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y + 45, 200, 10);
                }
            }

            draw(renderAttacks = true) {
                // Render character body
                this.drawCharacterSprite();
                
                // Blocking visual removed
                
                // Render attacks based on character-specific layering
                if (renderAttacks && this.state === 'attack' && this.currentMove) {
                    this.drawAttackLayer();
                }
                
                this.drawHealthBar(this.isPlayer ? 50 : 560, 50);
                
                // Debug facing indicator
                if (SPRITE_DEBUG_MODE) {
                    ctx.save();
                    ctx.fillStyle = this.isPlayer ? '#00ff00' : '#ff0000';
                    ctx.font = 'bold 16px monospace';
                    ctx.textAlign = 'center';
                    const arrow = this.facing === 1 ? '→' : '←';
                    ctx.fillText(`Facing: ${arrow}`, this.x, this.y - 120);
                    ctx.restore();
                }
                
                // Debug hitbox/hurtbox visualization
                if (HITBOX_DEBUG_MODE) {
                    ctx.save();
                    
                    // Draw hurtboxes (where you can be hit) in blue
                    ctx.strokeStyle = this.isPlayer ? '#0088ff' : '#8800ff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    this.hurtboxes.forEach(box => {
                        ctx.strokeRect(
                            this.x + box.x,
                            this.y + box.y,
                            box.width,
                            box.height
                        );
                    });
                    
                    // Draw hitboxes (where you can hit) in red/green
                    ctx.strokeStyle = this.isPlayer ? '#00ff00' : '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    this.hitboxes.forEach(box => {
                        if (box.type === 'throw') {
                            ctx.strokeStyle = '#ffff00';  // Yellow for throws
                        }
                        ctx.strokeRect(
                            this.x + box.x,
                            this.y + box.y,
                            box.width,
                            box.height
                        );
                        
                        // Label the hitbox type
                        ctx.fillStyle = ctx.strokeStyle;
                        ctx.font = '12px monospace';
                        ctx.fillText(
                            box.type || 'hit',
                            this.x + box.x + 2,
                            this.y + box.y + 12
                        );
                    });
                    
                    // Draw character center point
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
            
            drawAttackLayer() {
                // Draw attack effects based on the current move
                if (!this.currentMove || this.state !== 'attack') return;
                
                // Get current sprite for accurate positioning
                const spriteKey = this.getSpriteKey();
                
                // Draw attack trail effects for special moves
                if (this.currentMove === 'tatsumaki' || this.currentMove === 'shoryuken') {
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    
                    // Draw motion blur effect
                    for (let i = 1; i <= 3; i++) {
                        ctx.globalAlpha = 0.6 - (i * 0.15);
                        ctx.save();
                        ctx.translate(this.x - (this.facing * i * 15), this.y - (i * 5));
                        this.drawCharacterSprite(true);
                        ctx.restore();
                    }
                    
                    ctx.restore();
                }
                
                // Remove the green/red glow effect - it was too distracting
            }
            
            getSpriteKey() {
                // Get the current sprite key for this state
                let spriteState = 'idle';
                
                if (this.state === 'attack' && this.currentMove) {
                    if (this.currentMove === 'P' && this.characterName === 'elon') {
                        spriteState = (this.punchCount % 2 === 0) ? 'punch' : 'punch2';
                    } else {
                        const moveSpriteMap = {
                            'P': 'punch',
                            'K': 'kick-standing',
                            'crP': 'crouch-punch',
                            'crK': 'crouch-kick',
                            'jP': 'jumppunch-elon',
                            'jK': 'jump-kick',
                            'hadouken': 'hadouken',  // Maps to powermove-1.png for Elon
                            'shoryuken': 'punch',    // Use punch sprite for shoryuken
                            'tatsumaki': 'kick-standing'  // Use kick sprite for tatsumaki
                        };
                        spriteState = moveSpriteMap[this.currentMove] || this.currentMove;
                    }
                }
                
                return spriteState;
            }
        }

        // Flame particle for flamethrower
        class FlameParticle {
            constructor(x, y, facing) {
                this.x = x;
                this.y = y;
                this.facing = facing;
                this.velocity = facing * (10 + Math.random() * 5);
                this.life = 25 + Math.random() * 15;
                this.maxLife = this.life;
                this.size = 10 + Math.random() * 15;
                this.yVel = (Math.random() - 0.5) * 3;
                this.color = Math.random() < 0.6 ? '#ff6600' : (Math.random() < 0.5 ? '#ffaa00' : '#ffdd00');
            }

            update() {
                this.x += this.velocity;
                this.y += this.yVel;
                this.yVel -= 0.15; // Flames rise
                this.life--;
                this.velocity *= 0.97; // Slow down
                this.size *= 0.98; // Shrink
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha * 0.8;
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = this.color;
                const currentSize = this.size;
                
                // Draw flame without shadow blur for better performance
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright core
                ctx.globalAlpha = alpha * 0.6;
                ctx.fillStyle = '#ffffcc';
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Money bill for Trump's money throw
        class MoneyBill {
            constructor(x, y, facing) {
                this.x = x;
                this.y = y;
                this.facing = facing;
                this.velocity = facing * (12 + Math.random() * 6);
                this.yVel = -2 + Math.random() * 4; // Reduced vertical spread
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.3;
                this.life = 60;
                this.scale = 0.7; // 30% smaller (70% of original size)
                this.hasHit = false; // Track if this bill has hit
                this.hitbox = { width: 40, height: 20 }; // Individual bill hitbox
            }
            
            update() {
                this.x += this.velocity;
                this.y += this.yVel;
                this.yVel += 0.3; // Gravity
                this.rotation += this.rotationSpeed;
                this.life--;
                this.velocity *= 0.98; // Air resistance
            }
            
            draw() {
                if (!cashLoaded) return;
                
                const alpha = Math.min(1, this.life / 20);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                
                // Draw cash image at its actual size
                ctx.drawImage(cashImage, -cashImage.width/2, -cashImage.height/2);
                
                ctx.restore();
            }
        }

        // Text effect for special moves
        class TextEffect extends Particle {
            constructor(x, y, text, color, size = 48) {
                super(x, y, 'text');
                this.text = text;
                this.color = color;
                this.size = size;
                this.life = 60;
                this.vx = 0;
                this.vy = -2;
                this.scale = 1;
            }
            
            update() {
                this.y += this.vy;
                this.vy *= 0.95; // Slow down over time
                this.life--;
                
                // Scale effect
                if (this.life > 50) {
                    this.scale = 1 + (60 - this.life) * 0.05;
                } else if (this.life < 10) {
                    this.scale = this.life / 10;
                }
            }
            
            draw() {
                const alpha = Math.min(1, this.life / 30);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                
                // Shadow/outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.font = `italic bold ${this.size}px 'Brush Script MT', cursive`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText(this.text, 0, 0);
                
                // Main text
                ctx.fillStyle = this.color;
                ctx.fillText(this.text, 0, 0);
                
                ctx.restore();
            }
        }

        // Enhanced Projectile class (supports flamethrower, money throw, and hadouken)
        class Projectile {
            constructor(x, y, facing, owner, moveData) {
                this.x = x;
                this.y = y;
                this.facing = facing;
                this.owner = owner;
                this.moveData = moveData;
                this.active = true;
                this.isFlamethrower = owner.characterName === 'elon';
                this.isMoneyThrow = owner.characterName === 'trump';
                
                if (this.isFlamethrower) {
                    // Flamethrower properties
                    this.particles = [];
                    this.duration = 35;
                    this.hitbox = { x: facing === 1 ? 0 : -150, y: -40, width: 150, height: 80 };
                    this.particleSpawnTimer = 0;
                    this.hitCooldown = 0;
                    this.currentHits = 0;
                    this.moveType = 'flamethrower'; // Special move type for high chip damage
                    
                    // Override moveData for flamethrower to ensure proper damage
                    this.moveData = {
                        damage: 3,  // Flamethrower damage per hit
                        hitstun: 15,
                        blockstun: 10,
                        pushback: 2,
                        hits: 5,
                        projectile: true
                    };
                } else if (this.isMoneyThrow) {
                    // Money throw properties
                    this.moneyBills = [];
                    this.duration = 20; // Shorter burst
                    this.hitbox = { x: facing === 1 ? 0 : -100, y: -50, width: 100, height: 100 };
                    this.hitCooldown = 0;
                    this.currentHits = 0;
                    this.textShown = false;
                    this.moveType = 'hadouken'; // Store move type for blocking checks
                    
                    // Ensure money throw has damage properties
                    if (!this.moveData.damage) {
                        this.moveData = {
                            damage: 0.0125,  // Halved again
                            hitstun: 8,
                            blockstun: 6,
                            pushback: 1,
                            hits: 4,
                            projectile: true
                        };
                    }
                } else {
                    // Regular hadouken properties (for any future characters)
                    this.velocity = facing * 10;
                    this.hitbox = { x: -25, y: -25, width: 50, height: 50 };
                    this.rotation = 0;
                }
            }

            update() {
                if (this.isFlamethrower) {
                    // Flamethrower update logic
                    if (this.duration > 0) {
                        this.particleSpawnTimer++;
                        if (this.particleSpawnTimer % 3 === 0 && this.particles.length < 30) { // Spawn every 3 frames and limit particles
                            for (let i = 0; i < 2; i++) { // Only 2 particles instead of 4
                                this.particles.push(new FlameParticle(
                                    this.x,
                                    this.y + (Math.random() - 0.5) * 30,
                                    this.facing
                                ));
                            }
                        }
                        this.duration--;
                    }
                    
                    // Update particles
                    this.particles = this.particles.filter(p => {
                        p.update();
                        return p.life > 0;
                    });
                    
                    // Deactivate when no particles left
                    if (this.particles.length === 0 && this.duration <= 0) {
                        this.active = false;
                    }
                    
                    // Update hitbox position and size based on flame spread
                    if (this.duration > 0) {
                        const spread = (35 - this.duration) * 2;
                        this.hitbox.x = this.facing === 1 ? 0 : -(120 + spread);
                        this.hitbox.width = 120 + spread;
                    }
                } else if (this.isMoneyThrow) {
                    // Money throw update logic
                    if (this.duration > 0) {
                        // Spawn money bills
                        if (this.duration % 5 === 0) { // Spawn every 5 frames
                            for (let i = 0; i < 2; i++) {
                                this.moneyBills.push(new MoneyBill(
                                    this.x,
                                    this.y + (Math.random() - 0.5) * 40,
                                    this.facing
                                ));
                            }
                        }
                        this.duration--;
                        
                        // Show text effect once
                        if (!this.textShown && this.duration > 15) {
                            particles.push(new TextEffect(
                                this.x,
                                this.y - 100,
                                'HUSH MONEY!',
                                '#00ff00',
                                30
                            ));
                            this.textShown = true;
                        }
                    }
                    
                    // Update money bills
                    this.moneyBills = this.moneyBills.filter(bill => {
                        bill.update();
                        return bill.life > 0;
                    });
                    
                    // Deactivate when no bills left
                    if (this.moneyBills.length === 0 && this.duration <= 0) {
                        this.active = false;
                    }
                    
                    // Decrease hit cooldown for multi-hit
                    if (this.hitCooldown > 0) {
                        this.hitCooldown--;
                    }
                } else {
                    // Regular hadouken update logic
                    this.x += this.velocity;
                    this.rotation += 0.3;
                    
                    // Remove if off screen
                    if (this.x < -50 || this.x > canvas.width + 50) {
                        this.active = false;
                    }
                    
                    // Trail particles for hadouken
                    if (Math.random() > 0.7) {
                        particles.push(new Particle(
                            this.x + (Math.random() - 0.5) * 20,
                            this.y + (Math.random() - 0.5) * 20,
                            'energy'
                        ));
                    }
                }
            }

            draw() {
                if (this.isFlamethrower) {
                    // Draw all flame particles
                    this.particles.forEach(p => p.draw());
                } else if (this.isMoneyThrow) {
                    // Draw all money bills
                    this.moneyBills.forEach(bill => bill.draw());
                } else {
                    // Draw regular hadouken
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    
                    // Outer glow
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#00ccff';
                    
                    // Main fireball
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#00ffff');
                    gradient.addColorStop(0.6, '#0099ff');
                    gradient.addColorStop(1, 'rgba(0, 102, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner core
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Energy wisps
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.5)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 - this.rotation;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * 35, Math.sin(angle) * 35);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            }
        }

        // Advanced frame data with precise hitbox definitions - scaled for large sprites
        const FRAME_DATA = {
            // Standing attacks - hitboxes represent fist/foot position
            P: { 
                startup: 5, active: 3, recovery: 12, damage: 5, 
                hitstun: 16, blockstun: 13, pushback: 2, cancelable: true,
                hitboxes: [
                    { x: 90, y: -230, width: 60, height: 50 }  // Fist at shoulder height
                ],
                // Impact point - where the fist actually is in the sprite
                impactPoint: { x: 120, y: -230 }
            },
            K: { 
                startup: 7, active: 4, recovery: 18, damage: 7, 
                hitstun: 20, blockstun: 17, pushback: 4, cancelable: false,
                hitboxes: [
                    { x: 100, y: -180, width: 70, height: 60 },  // Knee/thigh
                    { x: 130, y: -120, width: 60, height: 50 }   // Foot extension
                ],
                // Impact point - where the foot strikes (same height as punch for high kick)
                impactPoint: { x: 160, y: -230 }
            },
            
            // Crouching attacks
            crP: { 
                startup: 4, active: 3, recovery: 10, damage: 4, 
                hitstun: 14, blockstun: 11, pushback: 1, cancelable: true, low: false,
                hitboxes: [
                    { x: 80, y: -140, width: 56, height: 44 }  // Lower fist position
                ],
                impactPoint: { x: 108, y: -140 }
            },
            crK: { 
                startup: 6, active: 4, recovery: 16, damage: 6, 
                hitstun: 0, blockstun: 14, pushback: 3, knockdown: true, low: true,
                hitboxes: [
                    { x: 90, y: -50, width: 80, height: 40 }  // Sweep at foot level
                ],
                impactPoint: { x: 130, y: -50 }
            },
            
            // Jumping attacks
            jP: { 
                startup: 6, active: 8, recovery: 0, damage: 6, 
                hitstun: 18, blockstun: 15, pushback: 2,
                hitboxes: [
                    { x: 80, y: -40, width: 64, height: 56 }  // Downward fist
                ],
                impactPoint: { x: 112, y: -40 }
            },
            jK: { 
                startup: 8, active: 6, recovery: 0, damage: 8, 
                hitstun: 22, blockstun: 18, pushback: 3,
                hitboxes: [
                    { x: 90, y: -20, width: 90, height: 70 }  // Extended jump kick
                ],
                impactPoint: { x: 135, y: -20 }
            },
            
            // Special moves
            hadouken: { 
                startup: 10, active: 35, recovery: 25, damage: 3, 
                hitstun: 10, blockstun: 8, pushback: 1, projectile: true, hits: 5,
                hitboxes: []  // Projectile handles its own collision
            },
            shoryuken: { 
                startup: 3, active: 14, recovery: 43, damage: 12, 
                hitstun: 30, blockstun: 0, pushback: 5, invincible: 8, knockdown: true,
                hitboxes: [
                    { x: 50, y: -280, width: 70, height: 280 }  // Rising uppercut
                ]
            },
            tatsumaki: { 
                startup: 11, active: 24, recovery: 18, damage: 4, 
                hitstun: 18, blockstun: 16, pushback: 4, hits: 3,
                hitboxes: [
                    { x: 100, y: -160, width: 80, height: 120 }  // Spinning kick
                ]
            },
            
            // Throw
            throw: { 
                startup: 3, active: 2, recovery: 24, damage: 12, range: THROW_RANGE,
                hitboxes: [
                    { x: 70, y: -200, width: 60, height: 160, type: 'throw' }
                ]
            }
        };

        // Input buffer system
        class InputBuffer {
            constructor() {
                this.buffer = [];
                this.maxBufferSize = 60;
                this.directions = [];
                this.buttons = [];
            }

            addDirection(dir) {
                this.directions.push({ dir, time: 0 });
                if (this.directions.length > 10) this.directions.shift();
            }

            addButton(btn) {
                this.buttons.push({ btn, time: 0 });
                if (this.buttons.length > 5) this.buttons.shift();
            }

            update() {
                // Age inputs
                this.directions.forEach(d => d.time++);
                this.buttons.forEach(b => b.time++);
                
                // Remove old inputs - increased window for gamepad
                this.directions = this.directions.filter(d => d.time < 45); // Increased from 30
                this.buttons = this.buttons.filter(b => b.time < 15); // Increased from 10
            }

            checkMotion(motion) {
                // Make motion detection more lenient
                // Check last 12 directions for the pattern (increased for gamepad)
                const recent = this.directions.slice(-12);
                if (recent.length < motion.length) return false;
                
                // Join all recent directions
                const motionStr = recent.map(d => d.dir).join('');
                
                // Debug log for player - only log when actually checking (not every frame)
                console.log('[INPUT] Checking motion:', motion, 'in buffer:', motionStr, '| Recent inputs age:', recent.map(d => d.time));
                
                // Check if motion exists anywhere in recent buffer
                if (motionStr.includes(motion)) {
                    console.log('[INPUT] Motion matched!', motion);
                    return true;
                }
                
                // Also check with some leniency - allow skipping neutral (5)
                const cleanedMotion = motionStr.replace(/5/g, '');
                if (cleanedMotion.includes(motion)) {
                    console.log('[INPUT] Motion matched with leniency!', motion);
                    return true;
                }
                
                // Additional leniency for gamepad - allow intermediate directions
                // But be more strict to prevent false positives
                if (motion === '236') {
                    // Hadouken - down->down-forward->forward motion
                    // Check last 8 inputs for the pattern
                    const recentStr = recent.slice(-8).map(d => d.dir).join('');
                    
                    // Match Hadouken patterns
                    if (recentStr.includes('236') ||           // Direct motion
                        recentStr.match(/2[35]*6/) ||          // With optional diagonal
                        recentStr.match(/[14]?2[35]*6/) ||     // Allow back->down->forward (common in quarter circles)
                        cleanedMotion.includes('236')) {       // Clean motion anywhere
                        console.log('[INPUT] Hadouken motion matched with gamepad leniency!');
                        return true;
                    }
                } else if (motion === '623') {
                    // Shoryuken - forward->down->down-forward (dragon punch)
                    // Must be more strict - no back input before the motion
                    const recentStr = recent.slice(-6).map(d => d.dir).join('');
                    
                    // Check if we have a proper Shoryuken motion
                    // Must NOT have back (4) immediately before the 623 motion
                    if (recentStr.match(/6[25]?3$/) ||         // Ends with proper 623
                        (recentStr.match(/[^4]623/) && !recentStr.match(/4.*623/)) ||  // Has 623 but no 4 before it
                        (recentStr === '623')) {                // Exact motion
                        console.log('[INPUT] Shoryuken motion matched with gamepad leniency!');
                        return true;
                    }
                } else if (motion === '214') {
                    // Tatsumaki - down->down-back->back motion
                    const recentStr = recent.slice(-8).map(d => d.dir).join('');
                    
                    if (recentStr.includes('214') ||           // Direct motion anywhere
                        recentStr.match(/2[15]*4/) ||          // With optional diagonal
                        recentStr.match(/[36]?2[15]*4/) ||     // Allow forward->down->back
                        cleanedMotion.includes('214')) {       // Clean motion anywhere
                        console.log('[INPUT] Tatsumaki motion matched with gamepad leniency!');
                        return true;
                    }
                }
                
                return false;
            }

            checkButton(btn) {
                return this.buttons.some(b => b.btn === btn && b.time < 5);
            }

            clear() {
                this.directions = [];
                this.buttons = [];
            }
        }

        // Enhanced AI Controller
        class AIController {
            constructor(fighter) {
                this.fighter = fighter;
                this.reactionTimer = 0;
                this.strategy = 'neutral';
                this.moveQueue = [];
                this.lastPlayerMove = null;
            }

            update(player) {
                if (this.reactionTimer > 0) {
                    this.reactionTimer--;
                    return;
                }
                
                // Check if AI attacks are disabled for testing
                if (aiAttackDisabled) {
                    // AI won't attack or block - stands still like a training dummy
                    const distance = Math.abs(this.fighter.x - player.x);
                    
                    // Disable blocking completely
                    this.fighter.blocking = false;
                    
                    // Just stand still - no movement at all
                    // This makes it easier to test throws and combos
                    // BUT don't override velocity during knockdown or being thrown!
                    if (this.fighter.state !== 'knockdown' && 
                        this.fighter.state !== 'beingThrown' &&
                        this.fighter.state !== 'hitstun') {
                        this.fighter.velocityX = 0;
                    }
                    
                    // Only set to idle if not in a special state
                    if (this.fighter.state !== 'beingThrown' && 
                        this.fighter.state !== 'throwingOpponent' &&
                        this.fighter.state !== 'knockdown' &&
                        this.fighter.state !== 'hitstun') {
                        this.fighter.state = 'idle';
                    }
                    
                    return;
                }
                
                const distance = Math.abs(this.fighter.x - player.x);
                const heightDiff = player.y - this.fighter.y;
                
                // Anti-air if player is jumping
                if (!player.grounded && distance < 120 && heightDiff < -50) {
                    this.fighter.inputBuffer.addDirection('6');
                    this.fighter.inputBuffer.addDirection('2');
                    this.fighter.inputBuffer.addDirection('3');
                    this.fighter.performSpecialMove('shoryuken');
                    this.reactionTimer = 30;
                    return;
                }
                
                // Block on reaction
                if (player.state === 'attack' && distance < 150) {
                    if (Math.random() < 0.8) {
                        this.fighter.blocking = true;
                        this.fighter.crouching = player.currentMove && (player.currentMove === 'crP' || player.currentMove === 'crK');
                        this.reactionTimer = 10;
                        return;
                    }
                }
                
                // Offensive patterns
                if (distance > 200) {
                    // Approach - heavily favor walking over jumping
                    const r = Math.random();
                    if (r < 0.05) {  // Only 5% chance to jump (was 30%)
                        this.fighter.jump(1);
                        this.reactionTimer = 40;
                    } else if (r < 0.15) {  // 10% chance for fireball
                        // Fireball
                        this.fighter.inputBuffer.addDirection('2');
                        this.fighter.inputBuffer.addDirection('3');
                        this.fighter.inputBuffer.addDirection('6');
                        this.fighter.performSpecialMove('hadouken');
                        this.reactionTimer = 60;
                    } else {  // 85% chance to walk forward
                        // Walk towards player
                        const direction = player.x > this.fighter.x ? 1 : -1;
                        this.fighter.walk(direction);
                        this.reactionTimer = 3;  // Shorter timer for smoother walking
                    }
                } else if (distance < 70) {
                    // Close combat
                    const r = Math.random();
                    if (r < 0.25) {
                        this.fighter.attack('P');
                        this.reactionTimer = 15;
                    } else if (r < 0.4) {
                        this.fighter.attack('K');
                        this.reactionTimer = 20;
                    } else if (r < 0.5) {
                        this.fighter.attemptThrow();
                        this.reactionTimer = 30;
                    } else if (r < 0.65) {
                        this.fighter.crouch();
                        this.fighter.attack('crK');
                        this.reactionTimer = 25;
                    } else if (r < 0.75) {
                        // Dragon punch
                        this.fighter.inputBuffer.addDirection('6');
                        this.fighter.inputBuffer.addDirection('2');
                        this.fighter.inputBuffer.addDirection('3');
                        this.fighter.performSpecialMove('shoryuken');
                        this.reactionTimer = 50;
                    }
                } else {
                    // Mid range - add more movement options
                    const r = Math.random();
                    if (r < 0.2) {  // 20% attack
                        this.fighter.attack('K');
                        this.reactionTimer = 25;
                    } else if (r < 0.3) {  // 10% crouch attack
                        this.fighter.crouch();
                        this.fighter.attack('crK');
                        this.reactionTimer = 35;
                    } else if (r < 0.35) {  // 5% jump (rare)
                        this.fighter.jump(Math.random() < 0.5 ? 1 : -1);
                        this.reactionTimer = 40;
                    } else {  // 65% walk to maintain optimal distance
                        // Walk towards optimal fighting distance
                        const optimalDistance = 100;
                        if (distance > optimalDistance) {
                            const direction = player.x > this.fighter.x ? 1 : -1;
                            this.fighter.walk(direction);
                        } else {
                            // Walk away if too close
                            const direction = player.x > this.fighter.x ? -1 : 1;
                            this.fighter.walk(direction);
                        }
                        this.reactionTimer = 5;
                    }
                }
                
                // Reset blocking
                if (this.fighter.blocking && player.state !== 'attack') {
                    this.fighter.blocking = false;
                }
            }
        }

        // Starbase construction site background
        function drawBackground() {
            if (backgroundLoaded && backgroundImage.complete) {
                // Draw the background image, scaling it to fit the canvas
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback: simple gradient if image hasn't loaded
                const skyGradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
                skyGradient.addColorStop(0, '#0a1929');
                skyGradient.addColorStop(0.5, '#1a2942');
                skyGradient.addColorStop(1, '#243752');
                ctx.fillStyle = skyGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Ground/concrete overlay (to ensure characters have a clear ground)
            ctx.fillStyle = 'rgba(42, 49, 56, 0.8)';
            ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
            
            // Ground texture lines
            ctx.strokeStyle = '#1f262b';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 30) {
                ctx.beginPath();
                ctx.moveTo(i, GROUND_Y);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            // Stage boundaries
            ctx.fillStyle = '#334455';
            ctx.fillRect(0, GROUND_Y - 10, 40, 10);
            ctx.fillRect(canvas.width - 40, GROUND_Y - 10, 40, 10);
        }

        // Initialize game
        const inputManager = new InputManager();
        const player = new Fighter(250, true, 'elon');
        const aiPlayer = new Fighter(710, false, 'trump');
        const aiController = new AIController(aiPlayer);
        
        // Set player reference for gamepad special moves
        inputManager.setPlayer(player);
        
        // Add fullscreen support for mobile
        function requestFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { // Safari
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }
        
        // Request fullscreen on first touch for mobile
        if (inputManager.isMobile) {
            document.addEventListener('touchstart', function() {
                requestFullscreen();
            }, { once: true });
        }
        
        // Load sprites for both characters
        async function initializeSprites() {
            try {
                await Promise.all([
                    spriteManager.loadCharacterSprites('elon'),
                    spriteManager.loadCharacterSprites('trump')
                ]);
                console.log('[GAME] Sprites loaded successfully for both characters');
            } catch (error) {
                console.error('[GAME] Failed to load some sprites:', error);
                // Game will still work with shape fallbacks
            }
        }
        
        // Start loading sprites and wait for them before starting the game
        initializeSprites().then(() => {
            console.log('[GAME] All sprites loaded, starting game loop');
            // Start game
            gameLoop();
        }).catch(error => {
            console.error('[GAME] Error loading sprites, starting with fallback:', error);
            // Start game anyway with vector fallbacks
            gameLoop();
        });
        
        // Use InputManager for key states
        const keys = inputManager.getKeys();

        // Collision detection (remains the same)
        function checkCollisions() {
            // Check all attacks
            [player, aiPlayer].forEach((attacker, i) => {
                const defender = i === 0 ? aiPlayer : player;
                
                // Skip collision checks during throw animations
                if (attacker.state === 'throwingOpponent' || defender.state === 'beingThrown') {
                    return;
                }
                
                // Debug throw hitboxes
                if (attacker.isPlayer && attacker.currentMove === 'throw' && attacker.hitboxes.length > 0) {
                    console.log('[THROW] Checking collisions:', {
                        attackerHitboxes: attacker.hitboxes.length,
                        defenderHurtboxes: defender.hurtboxes.length,
                        defenderState: defender.state,
                        defenderGrounded: defender.grounded
                    });
                }
                
                // Regular attacks
                attacker.hitboxes.forEach(hitbox => {
                    defender.hurtboxes.forEach(hurtbox => {
                        const hit1 = {
                            x: attacker.x + hitbox.x,
                            y: attacker.y + hitbox.y,
                            width: hitbox.width,
                            height: hitbox.height
                        };
                        const hurt2 = {
                            x: defender.x + hurtbox.x,
                            y: defender.y + hurtbox.y,
                            width: hurtbox.width,
                            height: hurtbox.height
                        };
                        
                        // Debug throw collision
                        if (hitbox.type === 'throw' && attacker.isPlayer) {
                            const xOverlap = hit1.x < hurt2.x + hurt2.width && hit1.x + hit1.width > hurt2.x;
                            const yOverlap = hit1.y < hurt2.y + hurt2.height && hit1.y + hit1.height > hurt2.y;
                            console.log('[THROW] Collision check:', {
                                hitbox: `x:${hit1.x}, y:${hit1.y}, w:${hit1.width}, h:${hit1.height}`,
                                hurtbox: `x:${hurt2.x}, y:${hurt2.y}, w:${hurt2.width}, h:${hurt2.height}`,
                                overlap: {
                                    x: xOverlap,
                                    y: yOverlap,
                                    bothAxes: xOverlap && yOverlap
                                }
                            });
                        }
                        
                        if (hit1.x < hurt2.x + hurt2.width &&
                            hit1.x + hit1.width > hurt2.x &&
                            hit1.y < hurt2.y + hurt2.height &&
                            hit1.y + hit1.height > hurt2.y) {
                            
                            // Hit confirmed
                            const moveData = FRAME_DATA[attacker.currentMove];
                            
                            // Skip if no move data (move was cleared)
                            if (!moveData) {
                                return;
                            }
                            
                            // Debug for throws
                            if (hitbox.type === 'throw' && attacker.isPlayer) {
                                console.log('[THROW] HIT CONFIRMED! Checking canHit...', {
                                    currentMoveHits: attacker.currentMoveHits,
                                    moveData: moveData
                                });
                            }
                            
                            const maxHits = moveData.hits || 1;
                            
                            // Check if we can hit again
                            let canHit = false;
                            if (maxHits === 1) {
                                // Single hit moves - only hit once
                                canHit = attacker.currentMoveHits === 0;
                            } else {
                                // Multi-hit moves - check hit limit and spacing
                                if (attacker.currentMoveHits < maxHits) {
                                    const framesSinceLastHit = attacker.moveFrame - attacker.lastHitFrame;
                                    const framesPerHit = Math.floor(moveData.active / maxHits);
                                    canHit = framesSinceLastHit >= framesPerHit;
                                }
                            }
                            
                            // More debug for throws
                            if (hitbox.type === 'throw' && attacker.isPlayer) {
                                console.log('[THROW] canHit result:', canHit);
                            }
                            
                            if (canHit) {
                                if (hitbox.type === 'throw') {
                                    // Debug all throw conditions
                                    if (attacker.isPlayer) {
                                        console.log('[THROW] Checking throw conditions:', {
                                            beingThrown: defender.beingThrown,
                                            grounded: defender.grounded,
                                            state: defender.state,
                                            knockdownFrames: defender.knockdownFrames,
                                            canBeThrown: !defender.beingThrown && defender.grounded && 
                                                defender.state !== 'knockdown' && defender.knockdownFrames <= 0 &&
                                                defender.state !== 'attack'
                                        });
                                    }
                                    
                                    // Check if opponent can be thrown
                                    if (!defender.beingThrown && defender.grounded && 
                                        defender.state !== 'knockdown' && defender.knockdownFrames <= 0 &&
                                        defender.state !== 'attack') {
                                        
                                        // First, clear any previous throw state
                                        defender.beingThrown = false;
                                        defender.throwAttacker = null;
                                        defender.throwAnimationFrame = 0;
                                        
                                        // Successful throw - instant execution for simplicity
                                        console.log('[THROW] SUCCESS! Throwing opponent');
                                        defender.beingThrown = true;
                                        defender.throwAttacker = attacker;
                                        defender.throwAnimationFrame = 0;
                                        defender.state = 'beingThrown';
                                        defender.velocityX = 0;
                                        defender.velocityY = 0;
                                        
                                        // Attacker enters throw state
                                        attacker.state = 'throwingOpponent';
                                        attacker.throwAnimationFrame = 0;
                                        attacker.moveFrame = 0; // Reset move frame
                                        
                                        // Clear attack state and hitboxes to prevent further collisions
                                        attacker.currentMove = null;
                                        attacker.isThrowAttempt = false;
                                        attacker.hitboxes = [];  // Clear all hitboxes immediately
                                        
                                        // Track successful throw hit
                                        attacker.currentMoveHits++;
                                        attacker.lastHitFrame = attacker.moveFrame;
                                        
                                        // Don't apply damage yet - wait for the slam
                                    }
                                    // Don't track hit here - let it fall through to avoid double-counting
                                } else {
                                    // Normal hit
                                    defender.takeDamage(
                                        moveData.damage,
                                        moveData.hitstun,
                                        moveData.blockstun,
                                        moveData.pushback,
                                        moveData.knockdown,
                                        attacker
                                    );
                                    
                                    // Track normal hit
                                    attacker.currentMoveHits++;
                                    attacker.lastHitFrame = attacker.moveFrame;
                                    attacker.lastHit = attacker.currentMove + attacker.moveFrame;
                                    
                                    // Build super meter for normal attacks
                                    attacker.superMeter = Math.min(attacker.maxSuper, 
                                        attacker.superMeter + moveData.damage * 0.5);
                                }
                            }
                        }
                    });
                });
                
                // Projectile collisions
                attacker.projectiles.forEach(proj => {
                    // Skip if projectile is not active
                    if (!proj.active) return;
                    
                    // Special handling for money throw - check each bill
                    if (proj.isMoneyThrow) {
                        proj.moneyBills.forEach(bill => {
                            if (bill.hasHit || bill.life <= 0) return;
                            
                            defender.hurtboxes.forEach(hurtbox => {
                                const billHit = {
                                    x: bill.x - bill.hitbox.width / 2,
                                    y: bill.y - bill.hitbox.height / 2,
                                    width: bill.hitbox.width,
                                    height: bill.hitbox.height
                                };
                                const hurt = {
                                    x: defender.x + hurtbox.x,
                                    y: defender.y + hurtbox.y,
                                    width: hurtbox.width,
                                    height: hurtbox.height
                                };
                                
                                if (billHit.x < hurt.x + hurt.width &&
                                    billHit.x + billHit.width > hurt.x &&
                                    billHit.y < hurt.y + hurt.height &&
                                    billHit.y + billHit.height > hurt.y) {
                                    
                                    // Debug collision angle
                                    if (defender.crouching && HITBOX_DEBUG_MODE) {
                                        console.log('[MONEY] Hit crouch:', {
                                            billY: bill.y,
                                            hurtboxTop: hurt.y,
                                            hurtboxBottom: hurt.y + hurt.height,
                                            yVel: bill.yVel
                                        });
                                    }
                                    
                                    // Create a modified attacker object with the projectile's move type
                                    const projectileAttacker = {
                                        ...attacker,
                                        currentMove: proj.moveType || 'hadouken'
                                    };
                                    
                                    defender.takeDamage(
                                        proj.moveData.damage,
                                        proj.moveData.hitstun,
                                        proj.moveData.blockstun,
                                        proj.moveData.pushback,
                                        false,
                                        projectileAttacker,
                                        true  // This is a projectile
                                    );
                                    
                                    bill.hasHit = true;
                                    bill.life = Math.min(bill.life, 10); // Make bill disappear quickly after hit
                                }
                            });
                        });
                        return;
                    }
                    
                    // Regular projectile collision (flamethrower, hadouken)
                    if (proj.hitCooldown > 0) {
                        proj.hitCooldown--;
                        return;
                    }
                    
                    defender.hurtboxes.forEach(hurtbox => {
                        const projHit = {
                            x: proj.x + proj.hitbox.x,
                            y: proj.y + proj.hitbox.y,
                            width: proj.hitbox.width,
                            height: proj.hitbox.height
                        };
                        const hurt = {
                            x: defender.x + hurtbox.x,
                            y: defender.y + hurtbox.y,
                            width: hurtbox.width,
                            height: hurtbox.height
                        };
                        
                        if (projHit.x < hurt.x + hurt.width &&
                            projHit.x + projHit.width > hurt.x &&
                            projHit.y < hurt.y + hurt.height &&
                            projHit.y + projHit.height > hurt.y) {
                            
                            // Create a modified attacker object with the projectile's move type
                            const projectileAttacker = {
                                ...attacker,
                                currentMove: proj.moveType || 'hadouken'
                            };
                            
                            defender.takeDamage(
                                proj.moveData.damage,
                                proj.moveData.hitstun,
                                proj.moveData.blockstun,
                                proj.moveData.pushback,
                                false,
                                projectileAttacker,
                                true  // This is a projectile
                            );
                            
                            // For flamethrower, don't destroy projectile, just add hit cooldown
                            if (proj.moveData.hits && proj.moveData.hits > 1) {
                                proj.hitCooldown = 8; // Wait 8 frames before next hit
                                proj.currentHits = (proj.currentHits || 0) + 1;
                                if (proj.currentHits >= proj.moveData.hits) {
                                    proj.active = false;
                                }
                            } else {
                                proj.active = false;
                            }
                        }
                    });
                });
            });
            
            // Push apart if too close
            const minDistance = 50;
            const distance = Math.abs(player.x - aiPlayer.x);
            if (distance < minDistance && Math.abs(player.y - aiPlayer.y) < 50) {
                const push = (minDistance - distance) / 2;
                if (player.x < aiPlayer.x) {
                    player.x -= push;
                    aiPlayer.x += push;
                } else {
                    player.x += push;
                    aiPlayer.x -= push;
                }
            }
        }

        // Main game loop
        window.gameOver = false;
        let winner = null;
        
        function gameLoop() {
            // Handle global effects
            if (hitPause > 0) {
                hitPause--;
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Update screen shake
            if (screenShake > 0) {
                screenShake *= 0.9;
                if (screenShake < 0.1) screenShake = 0;
            }
            
            // Clear with shake
            ctx.save();
            if (screenShake > 0) {
                ctx.translate(
                    Math.random() * screenShake - screenShake / 2,
                    Math.random() * screenShake - screenShake / 2
                );
            }
            
            // Draw background
            drawBackground();
            
            // Update game state
            if (!window.gameOver) {
                // Get fresh input state each frame
                const currentKeys = inputManager.getKeys();
                player.handleInput(currentKeys);
                player.update();
                
                aiController.update(player);
                aiPlayer.update();
                
                checkCollisions();
                
                // Update combo counter
                if (comboTimer > 0) {
                    comboTimer--;
                    if (comboTimer === 0) {
                        comboCounter = 0;
                        player.comboCount = 0;
                        aiPlayer.comboCount = 0;
                    }
                }
                
                if (player.comboCount > comboCounter || aiPlayer.comboCount > comboCounter) {
                    comboCounter = Math.max(player.comboCount, aiPlayer.comboCount);
                    comboTimer = 60;
                    
                    // Animate combo display
                    const comboDisplay = document.getElementById('comboDisplay');
                    comboDisplay.classList.remove('active');
                    void comboDisplay.offsetWidth; // Force reflow
                    comboDisplay.classList.add('active');
                }
                
                // Check win conditions
                if (player.health <= 0 || aiPlayer.health <= 0) {
                    window.gameOver = true;
                    winner = player.health > 0 ? 'ELON MUSK' : 'DONALD TRUMP';
                }
            }
            
            // Update particles
            particles = particles.filter(p => {
                p.update();
                return p.life > 0;
            });
            
            // Update after images
            afterImages = afterImages.filter(img => {
                img.update();
                return img.opacity > 0;
            });
            
            // Draw after images
            afterImages.forEach(img => img.draw());
            
            // Draw fighters with proper depth sorting
            const fighters = [player, aiPlayer].sort((a, b) => a.y - b.y);
            
            // Determine which fighter is Elon and which is Trump
            const elonFighter = player.characterName === 'elon' ? player : aiPlayer;
            const trumpFighter = player.characterName === 'trump' ? player : aiPlayer;
            
            // Dynamic depth switching based on active attacks
            let drawOrder = [...fighters]; // Default to Y-sorted order
            let impactFlashData = null; // Store impact flash info
            
            // Update depth switch timers
            fighters.forEach(fighter => {
                if (fighter.depthSwitchTimer > 0) {
                    fighter.depthSwitchTimer--;
                }
            });
            
            // Check if any fighter is actively hitting
            fighters.forEach(fighter => {
                if (fighter.state === 'attack' && fighter.currentMove && fighter.hitboxes.length > 0) {
                    const moveData = FRAME_DATA[fighter.currentMove];
                    if (moveData && fighter.moveFrame >= moveData.startup && 
                        fighter.moveFrame < moveData.startup + moveData.active) {
                        
                        // Check if making contact
                        const opponent = fighter === player ? aiPlayer : player;
                        const hitbox = fighter.hitboxes[0];
                        const hitboxX = fighter.x + hitbox.x;
                        const hitboxY = fighter.y + hitbox.y;
                        
                        // Check overlap with opponent's hurtbox
                        const hitting = hitboxX < opponent.x + 60 && 
                                      hitboxX + hitbox.width > opponent.x - 60 &&
                                      hitboxY < opponent.y && 
                                      hitboxY + hitbox.height > opponent.y - 298;
                        
                        if (hitting) {
                            // Set depth switch timer (active frames + 7 extra frames)
                            fighter.depthSwitchTimer = moveData.active + 7;
                            
                            // Store impact flash data for later
                            if (moveData.impactPoint) {
                                impactFlashData = {
                                    x: fighter.x + (fighter.facing === 1 ? moveData.impactPoint.x : -moveData.impactPoint.x),
                                    y: fighter.y + moveData.impactPoint.y
                                };
                            }
                        }
                    }
                }
                
                // Apply depth switch if timer is active
                if (fighter.depthSwitchTimer > 0) {
                    const opponent = fighter === player ? aiPlayer : player;
                    drawOrder = [opponent, fighter];
                }
            });
            
            // Draw fighters in determined order
            drawOrder.forEach(fighter => fighter.draw(true));
            
            // Draw impact flash on top of everything
            if (impactFlashData) {
                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffffff';
                ctx.beginPath();
                ctx.arc(impactFlashData.x, impactFlashData.y, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw particles
            particles.forEach(p => p.draw());
            
            // Draw projectiles
            player.projectiles.forEach(p => p.draw());
            aiPlayer.projectiles.forEach(p => p.draw());
            
            // Draw combo counter
            if (comboCounter > 1) {
                const comboDisplay = document.getElementById('comboDisplay');
                comboDisplay.textContent = `${comboCounter} HIT COMBO!`;
                comboDisplay.style.opacity = '1';
            } else {
                document.getElementById('comboDisplay').style.opacity = '0';
            }
            
            // Draw timer
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 48px Impact';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 10;
            ctx.strokeText('99', canvas.width / 2, 60);
            ctx.fillText('99', canvas.width / 2, 60);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'left';
            
            // Game over screen
            if (window.gameOver) {
                // Darken screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Victory text with animation
                const scale = 1 + Math.sin(Date.now() * 0.003) * 0.05;
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(scale, scale);
                
                // Winner text
                ctx.font = 'bold 80px Impact';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 6;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.strokeText(winner + ' WINS!', 0, 0);
                
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 10;
                ctx.fillText(winner + ' WINS!', 0, 0);
                
                ctx.restore();
                
                // Restart prompt
                ctx.font = '28px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fff';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;
                ctx.fillText('Press ESC to play again', canvas.width / 2, canvas.height / 2 + 100);
                ctx.textAlign = 'left';
                ctx.shadowBlur = 0;
            }
            
            ctx.restore();
            requestAnimationFrame(gameLoop);
        }
        
        // Game loop is now started after sprites load in initializeSprites()
    </script>
</body>
</html>